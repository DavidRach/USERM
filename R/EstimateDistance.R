#' Estimate Elliptical Distance Between Two USERM Spread Objects
#'
#' This function computes a distance matrix between fluorochrome pairs based on the geometric
#' relationship of their signal ellipses in two USERM spread objects (Spr). The distance is defined
#' as the ratio between the center-to-center distance and the sum of the ellipse radii along
#' the connecting line. A value less than 1 indicates overlapping ellipses.
#'
#' @param Spr1 A spread object generated by \code{EstimateSpread()}, containing intensity and variance information for a population.
#' @param Spr2 Another spread object generated by \code{EstimateSpread()}, to be compared with \code{Spr1}.
#'
#' @return A square numeric matrix with fluorochrome names as row and column names. Each entry represents
#' the elliptical distance ratio between a pair of fluorochromes in \code{Spr1} and \code{Spr2}.
#'
#' @details The function checks that both spread objects contain the same set of fluorochromes.
#' For each fluorochrome pair, it calculates:
#' \itemize{
#'   \item The center positions from intensity values.
#'   \item The ellipse radii from the square root of summed intercept and slope variances.
#'   \item The distance between ellipse centers.
#'   \item The sum of half-lengths of the line segments within each ellipse along the connecting direction.
#' }
#' The final distance ratio is computed as:
#' \deqn{(distance\_between\_centers + 0.01) / (sum\_of\_ellipse\_radii + 0.01)}
#'
#' @examples
#' \dontrun{
#'   dist_matrix <- EstimateDistance(Spr1, Spr2)
#'   heatmap(dist_matrix)
#' }
#'
#' @seealso \code{\link{EstimateSpread}}, \code{\link{EllipseLine_intersection}}
#'
#' @export


EstimateDistance = function(Spr1, Spr2){

  #check if Spr1 and Spr2 have the same fluors
  fluors = Spr1$fluors
  if(any(fluors != Spr2$fluors)){
    stop("The Spr1 and Spr2 do not have the same fluors.")
  }else{
    if(length(fluors) <= 1){
      stop("At least 2 fluors are needed.")
    }else{

      intensity_matrix = data.frame(Spr1 = Spr1$intensity_matrix, Spr2 = Spr2$intensity_matrix)
      colnames(intensity_matrix) = c("Spr1","Spr2")
      sigma_matrix = data.frame(Spr1 = sqrt(Spr1$intercept_sigma2 + Spr1$slop_sigma2),
                                Spr2 = sqrt(Spr2$intercept_sigma2 + Spr2$slop_sigma2))
      #prepare empty ED_mtx

      ED_mtx = array(0, dim = c(length(fluors), length(fluors))) #(channel, scc)
      colnames(ED_mtx) = fluors
      rownames(ED_mtx) = fluors

      for (i in 1:length(fluors)) {
        for (j in 1:length(fluors)) {

          fluor_i = fluors[i]
          fluor_j = fluors[j]

          #extract data
          center1 = c(intensity_matrix[fluor_i,"Spr1"],intensity_matrix[fluor_j,"Spr1"]) #x,y
          center2 = c(intensity_matrix[fluor_i,"Spr2"],intensity_matrix[fluor_j,"Spr2"])
          radius1 = c(sigma_matrix[fluor_i,"Spr1"],sigma_matrix[fluor_j,"Spr1"])
          radius2 = c(sigma_matrix[fluor_i,"Spr2"],sigma_matrix[fluor_j,"Spr2"])

          #calculate lineslop
          if(center1[1] == center1[2]){
            lineslop = Inf
          }else{
            lineslop = (center1[2] - center2[2]) / (center1[1] - center2[1])
          }
          #calculate dist1 (line length within ellipse1)
          mtx1 = EllipseLine_intersection(center = center1, radius = radius1, lineslop = lineslop)
          dist1 = sqrt((mtx1["p1","x"] - mtx1["p2","x"])^2 + (mtx1["p1","y"] - mtx1["p2","y"])^2) / 2

          #calculate dist2 (line length within ellipse2)
          mtx2 = EllipseLine_intersection(center = center2, radius = radius2, lineslop = lineslop)
          dist2 = sqrt((mtx2["p1","x"] - mtx2["p2","x"])^2 + (mtx2["p1","y"] - mtx2["p2","y"])^2) / 2

          #calculate dist_center (distance between centers of two ellipses)
          dist_center = sqrt((center1[1] - center2[1])^2 + (center1[2] - center2[2])^2)

          dist_ratio = (dist_center + 0.01) / (dist1 + dist2 + 0.01) #if < 1, intersect

          ED_mtx[fluor_i,fluor_j] = dist_ratio
        }
      }
    }
  }

  return(ED_mtx)
}





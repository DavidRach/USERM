})
output$intercept_matrix_weighted_html <- renderUI({
req(detector_cache$selected, fluor_cache$selected)
A = Userm$A[detector_cache$selected, fluor_cache$selected, drop = FALSE]
req(intercept_matrix_cache$matrix)
weighted_matrix = intercept_matrix_cache$matrix
final_col = matrix(apply(weighted_matrix,1,median),ncol = 1)
sqrt_col = sqrt(abs(final_col))
final_matrix = cbind(weighted_matrix, final_col)
final_matrix = cbind(final_matrix, sqrt_col)
colnames(final_matrix) = c(colnames(A),"median(Sigma^2)","abs(Sigma)")
rownames(final_matrix) = colnames(A)
HTML(Userm_html_table(mat = final_matrix, val_min = -10, val_mid = 0, val_max = 10,
colormin = "#2166ac", colormid = "#f7f7f7", colormax = "#b2182b"))
})
# slop_matrix_table
observe({
req(fluor_cache$selected)
updateSelectInput(session, "fluor_selector_slop_matrix_raw",
choices = fluor_cache$selected,
selected = fluor_cache$selected[1])
})
output$slop_matrix_raw_html <- renderUI({
req(detector_cache$selected, fluor_cache$selected)
slop_matrix = Userm$Res[[input$fluor_selector_slop_matrix_raw]]$slopMtx
slop_matrix = slop_matrix[detector_cache$selected,detector_cache$selected]
HTML(Userm_html_table(mat = slop_matrix, val_min = -1, val_mid = 0, val_max = 1,
colormin = "#2166ac", colormid = "#f7f7f7", colormax = "#b2182b"))
})
output$slop_matrix_weighted_html <- renderUI({
req(detector_cache$selected, fluor_cache$selected)
A = Userm$A[detector_cache$selected, fluor_cache$selected, drop = FALSE]
A_pinv = ginv(A)
colnames(A_pinv) = rownames(A)
rownames(A_pinv) = colnames(A)
weighted_matrix = array(0, dim = c(ncol(A), ncol(A))) #(channel, scc)
for (i in 1:ncol(A)) {
fluor = colnames(A)[i]
slop_matrix = Userm$Res[[fluor]]$slopMtx
slop_matrix = slop_matrix[detector_cache$selected,detector_cache$selected]
weighted_matrix[,i] = diag((A_pinv %*% slop_matrix) %*% t(A_pinv)) * intensity_cache$matrix[fluor,1]
}
final_col = matrix(apply(weighted_matrix,1,sum),ncol = 1)
sqrt_col = sqrt(abs(final_col))
final_matrix = cbind(weighted_matrix, final_col)
final_matrix = cbind(final_matrix, sqrt_col)
colnames(final_matrix) = c(colnames(A),"sum(Sigma^2)","abs(Sigma)")
rownames(final_matrix) = colnames(A)
HTML(Userm_html_table(mat = final_matrix, val_min = -10, val_mid = 0, val_max = 10,
colormin = "#2166ac", colormid = "#f7f7f7", colormax = "#b2182b"))
})
#prediction
observe({
req(fluor_cache$selected)
updateSelectInput(session, "prediction_plot_mode",
choices = c("Pseudo-color","Contour line"),
selected = "Pseudo-color")
updateSelectInput(session, "fluor_selector_x_prediction",
choices = fluor_cache$selected,
selected = fluor_cache$selected[1])
updateSelectInput(session, "fluor_selector_y_prediction",
choices = fluor_cache$selected,
selected = fluor_cache$selected[1])
updateSelectInput(session, "x_scale",
choices = c("Linear","Log10","Arcsinh"),
selected = "Linear")
updateSelectInput(session, "y_scale",
choices = c("Linear","Log10","Arcsinh"),
selected = "Linear")
})
output$prediction_plot <- renderPlot({
req(detector_cache$selected, fluor_cache$selected)
req(intercept_matrix_cache$matrix)
intercept_matrix = intercept_matrix_cache$matrix
intercept_col = matrix(apply(intercept_matrix,1,median),ncol = 1)
# A = Userm$A
A = Userm$A[detector_cache$selected, fluor_cache$selected, drop = FALSE]
A_pinv = ginv(A)
colnames(A_pinv) = rownames(A)
rownames(A_pinv) = colnames(A)
weighted_matrix = array(0, dim = c(ncol(A), ncol(A))) #(channel, scc)
intensity_col = array(0, dim = c(ncol(A), 1)) #(channel, 1)
for (i in 1:ncol(A)) {
fluor = colnames(A)[i]
slop_matrix = Userm$Res[[fluor]]$slopMtx
slop_matrix = slop_matrix[detector_cache$selected,detector_cache$selected]
weighted_matrix[,i] = diag((A_pinv %*% slop_matrix) %*% t(A_pinv)) * intensity_cache$matrix[fluor,1]
intensity_col[i,1] = intensity_cache$matrix[fluor,1]
}
spread_col = matrix(apply(weighted_matrix,1,sum),ncol = 1)
final_col = spread_col + intercept_col * (input$intercept_factor / 100)
sqrt_col = sqrt(abs(final_col))
rownames(sqrt_col) = colnames(A)
rownames(intensity_col) = colnames(A)
#Calculate iso band data
mu_x = intensity_col[input$fluor_selector_x_prediction,1]
mu_y = intensity_col[input$fluor_selector_y_prediction,1]
sigma_x = sqrt_col[input$fluor_selector_x_prediction,1]
sigma_y = sqrt_col[input$fluor_selector_y_prediction,1]
# create grid
x <- create_seq(min = input$x_min_input,
max = input$x_max_input, len=100,
scale = input$x_scale, cofactor = input$x_cofactor)
y <- create_seq(min = input$y_min_input,
max = input$y_max_input, len=100,
scale = input$y_scale, cofactor = input$y_cofactor)
grid <- expand.grid(x = x, y = y)
# calculate intensity for x and y
fx <- dnorm(grid$x, mean = mu_x, sd = sigma_x)
fy <- dnorm(grid$y, mean = mu_y, sd = sigma_y)
# Joint probability density (due to independence, it equals the product of individual densities)
grid$z <- fx * fy
#visualize iso band data
p = PredIsobandPlot(grid = grid,
x_scale = input$x_scale,
y_scale = input$y_scale,
x_cofactor = input$x_cofactor,
y_cofactor = input$y_cofactor,
x_label = input$fluor_selector_x_prediction,
y_label = input$fluor_selector_y_prediction,
x_min = input$x_min_input,
x_max = input$x_max_input,
y_min = input$y_min_input,
y_max = input$y_max_input,
mode = input$prediction_plot_mode)
p
})
#Export
observe({
req(fluor_cache$selected)
updateSelectInput(session, "prediction_Nx1_fluor",
choices = fluor_cache$selected,
selected = fluor_cache$selected[1])
})
#downloadHTML
output$downloadHTML <- downloadHandler(
filename = function() {
paste0("UsermOne_report-", format(Sys.time(), "%Y-%m-%d_%H_%M_%S"), ".html")
},
content = function(file) {
tempReport <- system.file("report_tmp", "UsermOnereport.Rmd", package = "USERM")
# tempReport <- file.path(report_tmp_dir, "UsermOnereport.Rmd")
file.copy("UsermOnereport.Rmd", tempReport, overwrite = TRUE)
params <- list(Userm = Userm,
detector_selected = detector_cache$selected,
fluor_selected = fluor_cache$selected,
prediction_plot_mode_report = input$prediction_plot_mode_report,
population_id = population_id)
rmarkdown::render(tempReport, output_file = file,
params = params,
output_format = "html_document",
envir = new.env(parent = globalenv()))
}
)
#downloadNxN
output$downloadNxN <- downloadHandler(
filename = function() {
paste0("UsermOne_NxN-", format(Sys.time(), "%Y-%m-%d_%H_%M_%S"), ".html")
},
content = function(file) {
tempReport <- system.file("report_tmp", "UsermOneNxN.Rmd", package = "USERM")
# tempReport <- file.path(report_tmp_dir, "UsermOneNxN.Rmd")
file.copy("UsermOneNxN.Rmd", tempReport, overwrite = TRUE)
params <- list(Userm = Userm,
detector_selected = detector_cache$selected,
fluor_selected = fluor_cache$selected,
prediction_plot_mode_report = input$prediction_plot_mode_report,
population_id = population_id)
rmarkdown::render(tempReport, output_file = file,
params = params,
output_format = "html_document",
envir = new.env(parent = globalenv()))
}
)
#downloadNx1
output$downloadNx1 <- downloadHandler(
filename = function() {
paste0("UsermOne_Nx1-", format(Sys.time(), "%Y-%m-%d_%H_%M_%S"), ".html")
},
content = function(file) {
tempReport <- system.file("report_tmp", "UsermOneNx1.Rmd", package = "USERM")
# tempReport <- file.path(report_tmp_dir, "UsermOneNx1.Rmd")
file.copy("UsermOneNx1.Rmd", tempReport, overwrite = TRUE)
params <- list(Userm = Userm,
detector_selected = detector_cache$selected,
fluor_selected = fluor_cache$selected,
prediction_plot_mode_report = input$prediction_plot_mode_report,
x_fluor = input$prediction_Nx1_fluor,
population_id = population_id)
rmarkdown::render(tempReport, output_file = file,
params = params,
output_format = "html_document",
envir = new.env(parent = globalenv()))
}
)
}
# running App
shinyApp(ui = ui, server = server)
}
PredOneSpread_update(Userm = UsermObj,population_id = c("V1"))
devtools::install_github("xiangmingcai/USERM")
devtools::document()
devtools::document()
devtools::document()
devtools::install_github("xiangmingcai/USERM")
# devtools::install_github("xiangmingcai/USERM")
library(USERM)
# Step 1 querySig
Sig_info = querySig()
# Step 2 Select fluors and create UsermObj
# fluors_selected = c(Sig_info$id[c(32:38,41:42,46:48,50:54,8,9,12,63)])#,58:62,8,9,12,14,18,24,25,26,63
fluors_selected = c(Sig_info$id[c(149,201,150,151,
152,153,154,155,
156,157,158,159,
160,161,162,163,
189,200,196,199,138)])#,58:62,8,9,12,14,18,24,25,26,63
print(fluors_selected)
Sig_mtx  = getSigMtx(ids = fluors_selected)
dim(Sig_mtx)
UsermObj = CreateUserm(A = Sig_mtx)
#add ResObj into UsermObj
for (save_suf in colnames(Sig_mtx)) {
ResObj = getRes(id = save_suf)
UsermObj = AddRes2Userm(Res = ResObj, Userm = UsermObj)
}
PredOneSpread(Userm = UsermObj,population_id = c("V1"))
UsermObj$Intensity_mtx[,2] = UsermObj$Intensity_mtx[,1]
UsermObj$Intensity_mtx[,3] = UsermObj$Intensity_mtx[,1]
UsermObj$Intensity_mtx[20,2] = UsermObj$Intensity_mtx[20,1]*5
UsermObj$Intensity_mtx[20,3] = UsermObj$Intensity_mtx[20,1]*10
PredMultipleSpread(Userm = UsermObj,population_ids = c("V1","V2","V3"))
# PredOneSpread_update(Userm = UsermObj,population_id = c("V1"))
UsermObj$Intensity_mtx[,1] = 0
UsermObj$Intensity_mtx[,2] = UsermObj$Intensity_mtx[,1]
UsermObj$Intensity_mtx[,3] = UsermObj$Intensity_mtx[,1]
UsermObj$Intensity_mtx[20,2] = 100
UsermObj$Intensity_mtx[20,2] = UsermObj$Intensity_mtx[20,1]*5
UsermObj$Intensity_mtx[20,3] = UsermObj$Intensity_mtx[20,1]*10
# Step 4 matrics estimation and visualization
Coef_mtx = EstimateCoefMtx(Userm = UsermObj)
# pdf(file = "E:/ResidualModel/CoefMtx.pdf",width = 10,height = 10)
Vis_Mtx(mat = Coef_mtx,mincolor = "white",midcolor = "white", maxcolor = "#95ABDB",
max = 20,mid = 10,min = 0,legend_name = "Coef",
title = "Coefficient of residual model matrix (Coef Matrix) (row spread into column)")
# devtools::install_github("xiangmingcai/USERM")
library(USERM)
# Step 1 querySig
Sig_info = querySig()
head(Sig_info)
# Step 2 Select fluors and create UsermObj
# fluors_selected = c(Sig_info$id[c(32:38,41:42,46:48,50:54,8,9,12,63)])#,58:62,8,9,12,14,18,24,25,26,63
fluors_selected = c(Sig_info$id[c(149,201,150,151,
152,153,154,155,
156,157,158,159,
160,161,162,163,
189,200,196,199,138)])#,58:62,8,9,12,14,18,24,25,26,63
print(fluors_selected)
Sig_mtx  = getSigMtx(ids = fluors_selected)
dim(Sig_mtx)
UsermObj = CreateUserm(A = Sig_mtx)
#add ResObj into UsermObj
for (save_suf in colnames(Sig_mtx)) {
ResObj = getRes(id = save_suf)
UsermObj = AddRes2Userm(Res = ResObj, Userm = UsermObj)
}
#create 3 populations with all zero fluroescence intensities
UsermObj$Intensity_mtx[,1] = 0
UsermObj$Intensity_mtx[,2] = UsermObj$Intensity_mtx[,1]
UsermObj$Intensity_mtx[,3] = UsermObj$Intensity_mtx[,1]
# assign 100, 500, 1000 to the PECy7 intensities of these 3 populations
UsermObj$Intensity_mtx[20,1] = 100
UsermObj$Intensity_mtx[20,2] = 500
UsermObj$Intensity_mtx[20,3] = 1000
View(UsermObj)
UsermObj[["Intensity_mtx"]]
print(UsermObj[["Intensity_mtx"]])
PredMultipleSpread(Userm = UsermObj,population_ids = c("V1","V2","V3"))
PredOneSpread(Userm = UsermObj,population_id = c("V1"))
# pdf(file = "E:/ResidualModel/CoefMtx.pdf",width = 10,height = 10)
Vis_Mtx(mat = UsermObj$A,mincolor = "white",midcolor = "#D03E4C", maxcolor = "#B02B38",
max = 1,mid = 0.5,min = 0,legend_name = "Signal",
title = "Signature matrix")
# pdf(file = "E:/ResidualModel/CoefMtx.pdf",width = 10,height = 10)
Vis_Mtx(mat = t(UsermObj$A),mincolor = "white",midcolor = "#D03E4C", maxcolor = "#B02B38",
max = 1,mid = 0.5,min = 0,legend_name = "Signal",
title = "Signature matrix")
# pdf(file = "E:/ResidualModel/CoefMtx.pdf",width = 10,height = 10)
Vis_Mtx(mat = UsermObj$A,mincolor = "white",midcolor = "#D03E4C", maxcolor = "#B02B38",
max = 1,mid = 0.5,min = 0,legend_name = "Signal",
title = "Signature matrix")
pdf(file = "E:/ResidualModel/Signature matrix.pdf",width = 6,height = 10)
Vis_Mtx(mat = UsermObj$A,mincolor = "white",midcolor = "#D03E4C", maxcolor = "#B02B38",
max = 1,mid = 0.5,min = 0,legend_name = "Signal",
title = "Signature matrix")
dev.off()
pdf(file = "E:/ResidualModel/Signature matrix.pdf",width = 6,height = 12)
Vis_Mtx(mat = UsermObj$A,mincolor = "white",midcolor = "#D03E4C", maxcolor = "#B02B38",
max = 1,mid = 0.5,min = 0,legend_name = "Signal",
title = "Signature matrix")
dev.off()
A = UsermObj$A
library(MASS)
pinv_A = pinv(A)
pinv_A = ginv(A)
Vis_Mtx(mat = pinv_A,mincolor = "white",midcolor = "#D03E4C", maxcolor = "#B02B38",
max = 1,mid = 0.5,min = 0,legend_name = "Value",
title = "Pseudo-inverse matrix")
Vis_Mtx(mat = pinv_A,mincolor = "#95ABDB",midcolor = "white", maxcolor = "#B02B38",
max = 1,mid = 0,min = -1,legend_name = "Value",
title = "Pseudo-inverse matrix")
colnames(A_pinv) = rownames(A)
rownames(A_pinv) = colnames(A)
library(MASS)
A_pinv = ginv(A)
colnames(A_pinv) = rownames(A)
rownames(A_pinv) = colnames(A)
Vis_Mtx(mat = A_pinv,mincolor = "#95ABDB",midcolor = "white", maxcolor = "#B02B38",
max = 1,mid = 0,min = -1,legend_name = "Value",
title = "Pseudo-inverse matrix")
A_pinv_t = t(A_pinv)
A_pinv_t = t(A_pinv)
Vis_Mtx(mat = A_pinv_t,mincolor = "#95ABDB",midcolor = "white", maxcolor = "#B02B38",
max = 1,mid = 0,min = -1,legend_name = "Value",
title = "transpose of Pseudo-inverse matrix")
dev.off()
A_pinv_t = t(A_pinv)
pdf(file = "E:/ResidualModel/transpose pinv matrix.pdf",width = 6,height = 12)
Vis_Mtx(mat = A_pinv_t,mincolor = "#95ABDB",midcolor = "white", maxcolor = "#B02B38",
max = 1,mid = 0,min = -1,legend_name = "Value",
title = "transpose of Pseudo-inverse matrix")
dev.off()
Vis_Mtx(mat = A_pinv,mincolor = "#95ABDB",midcolor = "white", maxcolor = "#B02B38",
max = 1,mid = 0,min = -1,legend_name = "Value",
title = "Pseudo-inverse matrix")
slop_mtx = UsermObj$Res$SCC3_Cell_PECy7_CD4$slopMtx
View(slop_mtx)
slop_mtx = UsermObj$Res$SCC3_Cell_PECy7_CD4$slopMtx
Vis_Mtx(mat = slop_mtx,mincolor = "#95ABDB",midcolor = "white", maxcolor = "#B02B38",
max = 1,mid = 0,min = -1,legend_name = "beta",
title = "slop matrix")
dev.off()
pdf(file = "E:/ResidualModel/slop matrix.pdf",width = 12,height = 12)
slop_mtx = UsermObj$Res$SCC3_Cell_PECy7_CD4$slopMtx
Vis_Mtx(mat = slop_mtx,mincolor = "#95ABDB",midcolor = "white", maxcolor = "#B02B38",
max = 1,mid = 0,min = -1,legend_name = "beta",
title = "slop matrix")
dev.off()
View(A_pinv)
A_pinv["SCC3_Cell_PECy7_CD4",]
A_pinv["SCC3_Cell_PECy7_CD4",]%o%A_pinv["SCC3_Cell_PECy7_CD4",]
A_pinv["SCC3_Cell_PECy7_CD4",1:2]
A_pinv["SCC3_Cell_PECy7_CD4",1:2]%o%A_pinv["SCC3_Cell_PECy7_CD4",1:2]
(-0.01655523 )*(-0.01655523 )
(-0.01655523 )*(-0.01363050 )
(-0.01363050 )*(-0.01363050 )
weight_mtx = A_pinv["SCC3_Cell_PECy7_CD4",]%o%A_pinv["SCC3_Cell_PECy7_CD4",]
Vis_Mtx(mat = weight_mtx,mincolor = "#95ABDB",midcolor = "white", maxcolor = "#B02B38",
max = 1,mid = 0,min = -1,legend_name = "beta",
title = "weight matrix")
dev.off()
weight_mtx = A_pinv["SCC3_Cell_PECy7_CD4",]%o%A_pinv["SCC3_Cell_PECy7_CD4",]
pdf(file = "E:/ResidualModel/weight matrix.pdf",width = 12,height = 12)
Vis_Mtx(mat = weight_mtx,mincolor = "#95ABDB",midcolor = "white", maxcolor = "#B02B38",
max = 1,mid = 0,min = -1,legend_name = "weight",
title = "weight matrix")
dev.off()
b1 <- matrix(c(1, 2, 3, 4), nrow = 2)
b2 <- matrix(c(5, 6, 7, 8), nrow = 2)
b1
b2
# 计算哈达玛积
b3 <- b1 * b2
b3
weighted_slope_mtx = weight_mtx * slop_mtx
Vis_Mtx(mat = weighted_slope_mtx,mincolor = "#95ABDB",midcolor = "white", maxcolor = "#B02B38",
max = 1,mid = 0,min = -1,legend_name = "beta",
title = "weighted slop matrix")
Vis_Mtx(mat = weighted_slope_mtx,mincolor = "#95ABDB",midcolor = "white", maxcolor = "#B02B38",
max = 10,mid = 0,min = -10,legend_name = "value",
title = "weighted slop matrix")
pdf(file = "E:/ResidualModel/weight slope matrix.pdf",width = 12,height = 12)
Vis_Mtx(mat = weighted_slope_mtx,mincolor = "#95ABDB",midcolor = "white", maxcolor = "#B02B38",
max = 10,mid = 0,min = -10,legend_name = "value",
title = "weighted slop matrix")
dev.off()
sum(weighted_slope_mtx)
Vis_Mtx(mat = A_pinv,mincolor = "#95ABDB",midcolor = "white", maxcolor = "#B02B38",
max = 1,mid = 0,min = -1,legend_name = "Value",
title = "Pseudo-inverse matrix")
dev.off()
weight_mtx = A_pinv["SCC3_Cell_BV510_CD4",]%o%A_pinv["SCC3_Cell_BV510_CD4",]
pdf(file = "E:/ResidualModel/weight matrix.pdf",width = 12,height = 12)
Vis_Mtx(mat = weight_mtx,mincolor = "#95ABDB",midcolor = "white", maxcolor = "#B02B38",
max = 1,mid = 0,min = -1,legend_name = "weight",
title = "weight matrix")
dev.off()
weighted_slope_mtx = weight_mtx * slop_mtx
pdf(file = "E:/ResidualModel/weight slope matrix.pdf",width = 12,height = 12)
Vis_Mtx(mat = weighted_slope_mtx,mincolor = "#95ABDB",midcolor = "white", maxcolor = "#B02B38",
max = 10,mid = 0,min = -10,legend_name = "value",
title = "weighted slop matrix")
dev.off()
sum(weighted_slope_mtx)
ResObj = UsermObj$Res$SCC3_Cell_PECy7_CD4
ResObj$detectors
checkRes_covScatter(Res = ResObj,
detector1 = "B13-A",
detector2 = "B14-A")
checkSig_linePlot(id = SCC3_Cell_PECy7_CD4)
checkSig_linePlot(id = "SCC3_Cell_PECy7_CD4")
Similarity_mtx = EstimateSimilarityMtx(A = UsermObj$A)
# pdf(file = "E:/ResidualModel/SimilarityMtx.pdf",width = 10,height = 10)
Vis_Mtx(mat = Similarity_mtx,mincolor = "white",midcolor = "white", maxcolor = "#95ABDB",
max = 1,mid = 0.8,min = 0,legend_name = "Cosine",
title = "Cosine similarity matrix")
Hotspot_mtx = EstimateHotspotMtx(A = UsermObj$A)
# pdf(file = "E:/ResidualModel/HotspotMtx.pdf",width = 10,height = 10)
Vis_Mtx(mat = Hotspot_mtx,mincolor = "white",midcolor = "white", maxcolor = "#95ABDB",
max = 2,mid = 1,min = 0,legend_name = "Hotspot",
title = "Hotspot matrix")
devtools::document()
devtools::document()
devtools::install_github("xiangmingcai/USERM")
# devtools::install_github("xiangmingcai/USERM")
library(USERM)
# Step 1 querySig
Sig_info = querySig()
head(Sig_info)
fluor_to_check = Sig_info$id[3]
print(fluor_to_check)
checkSig_linePlot(id = fluor_to_check)
ResObj = getRes(id = fluor_to_check)
checkRes_slopMtx(Res = ResObj)
checkRes_interceptMtx(Res = ResObj)
print(ResObj$bin_mids)
checkRes_covMtx(Res = ResObj,bin=3)
ResObj$detectors
checkRes_covScatter(Res = ResObj,
detector1 = ResObj$detectors[1],
detector2 = ResObj$detectors[2])
# Step 2 Select fluors and create UsermObj
# fluors_selected = c(Sig_info$id[c(32:38,41:42,46:48,50:54,8,9,12,63)])#,58:62,8,9,12,14,18,24,25,26,63
fluors_selected = c(Sig_info$id[c(149,201,150,151,
152,153,154,155,
156,157,158,159,
160,161,162,163,
189,200,196,199,138)])#,58:62,8,9,12,14,18,24,25,26,63
print(fluors_selected)
Sig_mtx  = getSigMtx(ids = fluors_selected)
dim(Sig_mtx)
UsermObj = CreateUserm(A = Sig_mtx)
#add ResObj into UsermObj
for (save_suf in colnames(Sig_mtx)) {
ResObj = getRes(id = save_suf)
UsermObj = AddRes2Userm(Res = ResObj, Userm = UsermObj)
}
# Step 3 Make prediction (optional)
UsermObj$Scale_df$min = -2000
UsermObj$Scale_df$max = 5000
PredOneSpread(Userm = UsermObj,population_id = c("V1"))
UsermObj$Intensity_mtx[,2] = UsermObj$Intensity_mtx[,1]
UsermObj$Intensity_mtx[,3] = UsermObj$Intensity_mtx[,1]
# assign 100, 500, 1000 to the PECy7 intensities of these 3 populations
UsermObj$Intensity_mtx[20,1] = 100
UsermObj$Intensity_mtx[20,2] = 500
UsermObj$Intensity_mtx[20,3] = 1000
UsermObj$Intensity_mtx[,2] = 200*c(1:length(UsermObj$fluors))
UsermObj$Intensity_mtx[,3] = 300*c(1:length(UsermObj$fluors))
names(UsermObj$Intensity_mtx) = c("V1","V2","V3")
PredMultipleSpread(Userm = UsermObj,population_ids = c("V1","V2","V3"))
# Step 4 matrics estimation and visualization
Coef_mtx = EstimateCoefMtx(Userm = UsermObj)
# pdf(file = "E:/ResidualModel/CoefMtx.pdf",width = 10,height = 10)
Vis_Mtx(mat = Coef_mtx,mincolor = "white",midcolor = "white", maxcolor = "#95ABDB",
max = 20,mid = 10,min = 0,legend_name = "Coef",
title = "Coefficient of residual model matrix (Coef Matrix) (row spread into column)")
Hotspot_mtx = EstimateHotspotMtx(A = UsermObj$A)
# pdf(file = "E:/ResidualModel/HotspotMtx.pdf",width = 10,height = 10)
Vis_Mtx(mat = Hotspot_mtx,mincolor = "white",midcolor = "white", maxcolor = "#95ABDB",
max = 2,mid = 1,min = 0,legend_name = "Hotspot",
title = "Hotspot matrix")
Similarity_mtx = EstimateSimilarityMtx(A = UsermObj$A)
# pdf(file = "E:/ResidualModel/SimilarityMtx.pdf",width = 10,height = 10)
Vis_Mtx(mat = Similarity_mtx,mincolor = "white",midcolor = "white", maxcolor = "#95ABDB",
max = 1,mid = 0.8,min = 0,legend_name = "Cosine",
title = "Cosine similarity matrix")
Spr1 = EstimateSpread(Userm = UsermObj,population_id = c("P1"))
Spr2 = EstimateSpread(Userm = UsermObj,population_id = c("P2"))
SpreadDistance_mtx = EstimateDistance(Spr1, Spr2)
Vis_Mtx(mat = SpreadDistance_mtx,mincolor = "darkred",midcolor = "white", maxcolor = "white",max = 1.5,mid = 1,min = 0,title = "Spread Distance matrix")
A = UsermObj$A
pdf(file = "E:/ResidualModel/Signature matrix.pdf",width = 6,height = 12)
Vis_Mtx(mat = A,mincolor = "white",midcolor = "#D03E4C", maxcolor = "#B02B38",
max = 1,mid = 0.5,min = 0,legend_name = "Signal",
title = "Signature matrix")
dev.off()
dev.off()
dev.off()
# devtools::install_github("xiangmingcai/USERM")
library(USERM)
# #read in SCC fcs
library(flowCore)
library(MASS)
library(GateData)
library(ggplot2)
# library(reshape2)
# library(progress)
library(shiny)
# library(DT)
library(dplyr)
library(ComplexHeatmap)
library(circlize)

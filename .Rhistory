SuprObj = CreateUserm(A = Sig_mtx)
#add ResObj into SuprObj
for (save_suf in colnames(Sig_mtx)) {
ResObj = getRes(id = save_suf)
SuprObj = AddRes2Userm(Res = ResObj, Userm = SuprObj)
}
SuprObj[["Scale_df"]][["min"]] = -100
SuprObj[["Scale_df"]][["max"]] = 1000
SuprObj[["Scale_df"]][["scale"]] = "Linear"
SuprObj[["Scale_df"]][["cofactor"]] = 10
#
#
# SuprObj = AddScale(Userm = SuprObj,fluor = colnames(Sig_mtx)[1],min = -100, max = 1000, scale = "Linear", cofactor = 10)# c("Linear","Log10","Arcsinh")
# SuprObj = AddScale(Userm = SuprObj,fluor = colnames(Sig_mtx)[2],min = -100, max = 1000, scale = "Log10", cofactor = 10)# c("Linear","Log10","Arcsinh")
# SuprObj = AddScale(Userm = SuprObj,fluor = colnames(Sig_mtx)[3],min = -100, max = 1000, scale = "Arcsinh", cofactor = 10)# c("Linear","Log10","Arcsinh")
# SuprObj = AddScale(Userm = SuprObj,fluor = colnames(Sig_mtx)[4],min = -100, max = 1000, scale = "Arcsinh", cofactor = 10)# c("Linear","Log10","Arcsinh")
SuprObj$Intensity_mtx[,1] = 100*c(1:length(SuprObj$fluors))
PredOneSpread(Userm = SuprObj,population_id = c("V1"))
SuprObj$Intensity_mtx[,2] = 100*c(1:length(SuprObj$fluors))
SuprObj$Intensity_mtx[,3] = 200*c(1:length(SuprObj$fluors))
PredMultipleSpread(Userm = SuprObj,population_ids = c("V1","V2","V3"))
devtools::document()
# library(rmarkdown)
# library(patchwork)
#
devtools::install_github("xiangmingcai/USERM")
# library(rmarkdown)
# library(patchwork)
#
# devtools::install_github("xiangmingcai/USERM")
library(USERM)
#querySig
# library(grid)
Sig_info = querySig()
Sig_mtx  = getSigMtx(ids = c(Sig_info$id[c(66,69,71)]))
SuprObj = CreateUserm(A = Sig_mtx)
#add ResObj into SuprObj
for (save_suf in colnames(Sig_mtx)) {
ResObj = getRes(id = save_suf)
SuprObj = AddRes2Userm(Res = ResObj, Userm = SuprObj)
}
SuprObj[["Scale_df"]][["min"]] = -100
SuprObj[["Scale_df"]][["max"]] = 1000
SuprObj[["Scale_df"]][["scale"]] = "Linear"
SuprObj[["Scale_df"]][["cofactor"]] = 10
#
#
# SuprObj = AddScale(Userm = SuprObj,fluor = colnames(Sig_mtx)[1],min = -100, max = 1000, scale = "Linear", cofactor = 10)# c("Linear","Log10","Arcsinh")
# SuprObj = AddScale(Userm = SuprObj,fluor = colnames(Sig_mtx)[2],min = -100, max = 1000, scale = "Log10", cofactor = 10)# c("Linear","Log10","Arcsinh")
# SuprObj = AddScale(Userm = SuprObj,fluor = colnames(Sig_mtx)[3],min = -100, max = 1000, scale = "Arcsinh", cofactor = 10)# c("Linear","Log10","Arcsinh")
# SuprObj = AddScale(Userm = SuprObj,fluor = colnames(Sig_mtx)[4],min = -100, max = 1000, scale = "Arcsinh", cofactor = 10)# c("Linear","Log10","Arcsinh")
SuprObj$Intensity_mtx[,1] = 100*c(1:length(SuprObj$fluors))
SuprObj$Intensity_mtx[,2] = 100*c(1:length(SuprObj$fluors))
SuprObj$Intensity_mtx[,3] = 200*c(1:length(SuprObj$fluors))
colnames(SuprObj$Intensity_mtx)
PredMultipleSpread(Userm = SuprObj,population_ids = c("V1","V2","V3"))
Userm = SuprObj
detectors = Userm$detectors
fluors = Userm$fluors
View(Userm)
EstimateSpread = function(Userm,population_id){
if (!population_id %in% colnames(Userm$Intensity_mtx)) {
stop(paste0("The ",population_id," column is missing in Userm$Intensity_mtx."))
}
detectors = Userm$detectors
fluors = Userm$fluors
A = Userm$A
A = A[detectors, fluors, drop = FALSE]
intensity_matrix = Userm$Intensity_mtx[,population_id,drop = FALSE]
Userm$Res
A_pinv = ginv(A)
colnames(A_pinv) = rownames(A)
rownames(A_pinv) = colnames(A)
#calculate weighted intercept
weighted_matrix <- array(0, dim = c(ncol(A), ncol(A))) #(channel, scc)
for (i in 1:ncol(A)) {
fluor = colnames(A)[i]
intercept_matrix = Userm$Res[[fluor]]$interceptMtx
intercept_matrix = intercept_matrix[detectors,detectors]
weighted_matrix[,i] = diag((A_pinv %*% intercept_matrix) %*% t(A_pinv))
}
intercept_sigma2_col = matrix(apply(weighted_matrix,1,median),ncol = 1)
# intercept_sigma_col = sqrt(abs(intercept_sigma2_col))
rownames(intercept_sigma2_col) = colnames(A)
# rownames(intercept_sigma_col) = colnames(A)
#calculate weighted slop
weighted_matrix = array(0, dim = c(ncol(A), ncol(A))) #(channel, scc)
for (i in 1:ncol(A)) {
fluor = colnames(A)[i]
slop_matrix = Userm$Res[[fluor]]$slopMtx
slop_matrix = slop_matrix[detectors,detectors]
weighted_matrix[,i] = diag((A_pinv %*% slop_matrix) %*% t(A_pinv)) * intensity_matrix[fluor,1]
}
slop_sigma2_col = matrix(apply(weighted_matrix,1,sum),ncol = 1)
# slop_sigma_col = sqrt(abs(slop_sigma2_col))
rownames(slop_sigma2_col) = colnames(A)
# rownames(slop_sigma_col) = colnames(A)
Spr = list(population_id = population_id,
A = A,
fluors = fluors,
detectors = detectors,
intensity_matrix = intensity_matrix,
intercept_sigma2_col = intercept_sigma2_col,
slop_sigma2_col = slop_sigma2_col
)
return(Spr)
}
Spread_mtx = EstimateSpread(Userm = SuprObj,population_id = c("V1"))
View(Spread_mtx)
Spread_mtx[["intercept_sigma2_col"]]
Spread_mtx[["slop_sigma2_col"]]
Spread_mtx[["intensity_matrix"]]
Spread_mtx1 = EstimateSpread(Userm = SuprObj,population_id = c("V1"))
Spread_mtx2 = EstimateSpread(Userm = SuprObj,population_id = c("V2"))
View(Spread_mtx2)
View(Spread_mtx1)
SuprObj$Intensity_mtx[,1] = 100*c(1:length(SuprObj$fluors))
SuprObj$Intensity_mtx[,2] = 200*c(1:length(SuprObj$fluors))
SuprObj$Intensity_mtx[,3] = 300*c(1:length(SuprObj$fluors))
Spread_mtx1 = EstimateSpread(Userm = SuprObj,population_id = c("V1"))
Spread_mtx2 = EstimateSpread(Userm = SuprObj,population_id = c("V2"))
EstimateSpread = function(Userm,population_id){
if (!population_id %in% colnames(Userm$Intensity_mtx)) {
stop(paste0("The ",population_id," column is missing in Userm$Intensity_mtx."))
}
detectors = Userm$detectors
fluors = Userm$fluors
A = Userm$A
A = A[detectors, fluors, drop = FALSE]
intensity_matrix = Userm$Intensity_mtx[,population_id,drop = FALSE]
A_pinv = ginv(A)
colnames(A_pinv) = rownames(A)
rownames(A_pinv) = colnames(A)
#calculate weighted intercept
weighted_matrix <- array(0, dim = c(ncol(A), ncol(A))) #(channel, scc)
for (i in 1:ncol(A)) {
fluor = colnames(A)[i]
intercept_matrix = Userm$Res[[fluor]]$interceptMtx
intercept_matrix = intercept_matrix[detectors,detectors]
weighted_matrix[,i] = diag((A_pinv %*% intercept_matrix) %*% t(A_pinv))
}
intercept_sigma2_col = matrix(apply(weighted_matrix,1,median),ncol = 1)
# intercept_sigma_col = sqrt(abs(intercept_sigma2_col))
rownames(intercept_sigma2_col) = colnames(A)
# rownames(intercept_sigma_col) = colnames(A)
#calculate weighted slop
weighted_matrix = array(0, dim = c(ncol(A), ncol(A))) #(channel, scc)
for (i in 1:ncol(A)) {
fluor = colnames(A)[i]
slop_matrix = Userm$Res[[fluor]]$slopMtx
slop_matrix = slop_matrix[detectors,detectors]
weighted_matrix[,i] = diag((A_pinv %*% slop_matrix) %*% t(A_pinv)) * intensity_matrix[fluor,1]
}
slop_sigma2_col = matrix(apply(weighted_matrix,1,sum),ncol = 1)
# slop_sigma_col = sqrt(abs(slop_sigma2_col))
rownames(slop_sigma2_col) = colnames(A)
# rownames(slop_sigma_col) = colnames(A)
Spr = list(population_id = population_id,
A = A,
fluors = fluors,
detectors = detectors,
intensity_matrix = intensity_matrix,
intercept_sigma2 = intercept_sigma2_col,
slop_sigma2 = slop_sigma2_col
)
return(Spr)
}
Spread_mtx1 = EstimateSpread(Userm = SuprObj,population_id = c("V1"))
Spread_mtx2 = EstimateSpread(Userm = SuprObj,population_id = c("V2"))
Spread_mtx2[["intercept_sigma2"]]
Spr1 = EstimateSpread(Userm = SuprObj,population_id = c("V1"))
Spr2 = EstimateSpread(Userm = SuprObj,population_id = c("V2"))
#
fluors = Spr1$fluors
fluors = Spr1$fluors
ED_mtx = array(0, dim = c(length(fluors), length(fluors))) #(channel, scc)
colnames(ED_mtx) = fluors
rownames(ED_mtx) = fluors
fluors
ED_mtx
i = 1
j = 2
library(PlaneGeometry)
install.packages("PlaneGeometry")
library(PlaneGeometry)
install.packages('PlaneGeometry')
# 椭圆参数
a <- 5  # x轴半轴长度
b <- 3  # y轴半轴长度
# 直线斜率
m <- 2
# 计算交点
denominator <- 1 / a^2 + m^2 / b^2
denominator
x_val <- sqrt(1 / denominator)
y_val <- m * x_val
# 椭圆参数
a <- 5      # x轴半轴长度
b <- 3      # y轴半轴长度
h <- 2      # 椭圆中心横坐标
k <- -1     # 椭圆中心纵坐标
# 直线斜率
m <- 2      # 直线斜率
# 计算交点
denominator <- 1 / a^2 + m^2 / b^2
x_offset <- sqrt(1 / denominator)
# 两个交点的 x 坐标
x1 <- h - x_offset
x2 <- h + x_offset
# 对应的 y 坐标（代入直线方程 y = m(x - h) + k）
y1 <- m * (x1 - h) + k
y2 <- m * (x2 - h) + k
# 打印交点
points <- matrix(c(x1, y1, x2, y2), ncol = 2, byrow = TRUE)
colnames(points) <- c("x", "y")
print("交点坐标为：")
print(points)
# 绘制椭圆
theta <- seq(0, 2*pi, length.out = 300)
ellipse_x <- h + a * cos(theta)
ellipse_y <- k + b * sin(theta)
# 绘制直线
line_x <- seq(h - a, h + a, length.out = 100)
line_y <- m * (line_x - h) + k
# 绘图
plot(ellipse_x, ellipse_y, type = "l", col = "blue", asp = 1,
xlab = "x", ylab = "y", main = "椭圆与过中心直线的交点")
lines(line_x, line_y, col = "green", lty = 2)
points(points[,1], points[,2], col = "red", pch = 19)
abline(h = 0, v = 0, col = "gray", lty = 3)
legend("topright", legend = c("椭圆", "直线", "交点"),
col = c("blue", "green", "red"), lty = c(1, 2, NA), pch = c(NA, NA, 19))
plot(ellipse_x, ellipse_y, type = "l", col = "blue", asp = 1,
xlab = "x", ylab = "y", main = "椭圆与过中心直线的交点")
lines(line_x, line_y, col = "green", lty = 2)
points(points[,1], points[,2], col = "red", pch = 19)
abline(h = 0, v = 0, col = "gray", lty = 3)
matrix(nrow = 2,ncol = 2,dimnames = list(c("x","y"),c("p1","p2")))
matrix(nrow = 2,ncol = 2,dimnames = list(c("p1","p2"),c("x","y")))
mat = matrix(nrow = 2,ncol = 2,dimnames = list(c("p1","p2"),c("x","y")))
mat
x1
x2
mat = matrix(c(x1,x2,y1,y2),nrow = 2,ncol = 2,dimnames = list(c("p1","p2"),c("x","y")))
mat
y1
y2
EllipseLine_intersection(center = c(2,1), radius = c(5,3), lineslop = 1)
EllipseLine_intersection = function(center,radius,lineslop){
h = center[1] #x
k = center[2] #y
a = radius[1] #x
b = radius[2] #y
m = lineslop
if(m == Inf){
y_offset <- b
y1 <- k - y_offset
y2 <- k + y_offset
x1 <- h
x2 <- h
}else{
# calculate x_offset
denominator <- 1 / a^2 + m^2 / b^2
x_offset <- sqrt(1 / denominator)
# calculate intersection
x1 <- h - x_offset
x2 <- h + x_offset
y1 <- m * (x1 - h) + k
y2 <- m * (x2 - h) + k
}
mat = matrix(c(x1,x2,y1,y2),nrow = 2,ncol = 2,dimnames = list(c("p1","p2"),c("x","y")))
return(mat)
}
EllipseLine_intersection(center = c(2,1), radius = c(5,3), lineslop = 1)
(mtx["p1","x"] - mtx["p2","x"])^2
lineslop =
mtx = EllipseLine_intersection(center = c(2,1), radius = c(5,3), lineslop = 1)
(mtx["p1","x"] - mtx["p2","x"])^2
dist = sqrt((mtx["p1","x"] - mtx["p2","x"])^2 + (mtx["p1","y"] - mtx["p2","y"])^2)
dist
dist = sqrt((mtx["p1","x"] - mtx["p2","x"])^2 + (mtx["p1","y"] - mtx["p2","y"])^2) / 2
dist
center1 = c(2,1)
center2 = c(5,3)
(center1[2] - center2[2]) / (center1[1] - center2[1])
radius1 = c(5,3)
radius2 = c(3,2)
center1 = c(2,1) #x,y
center2 = c(5,3)
radius1 = c(5,3)
radius2 = c(3,2)
if(center1[1] == center1[2]){
lineslop = Inf
}else{
lineslop = (center1[2] - center2[2]) / (center1[1] - center2[1])
}
mtx1 = EllipseLine_intersection(center = center1, radius = radius1, lineslop = lineslop)
dist1 = sqrt((mtx1["p1","x"] - mtx1["p2","x"])^2 + (mtx1["p1","y"] - mtx1["p2","y"])^2) / 2
dist1
mtx2 = EllipseLine_intersection(center = center2, radius = radius2, lineslop = lineslop)
dist2 = sqrt((mtx2["p1","x"] - mtx2["p2","x"])^2 + (mtx2["p1","y"] - mtx2["p2","y"])^2) / 2
dist2
dist_center = sqrt((center1[1] - center2[1])^2 + (center1[2] - center2[2])^2)
dist_center
dist_ratio = (dist_center + 0.01) / (dist1 + dist2 + 0.01)
dist_ratio
center1 = c(20,1) #x,y
center2 = c(5,3)
radius1 = c(5,3)
radius2 = c(3,2)
#calculate lineslop
if(center1[1] == center1[2]){
lineslop = Inf
}else{
lineslop = (center1[2] - center2[2]) / (center1[1] - center2[1])
}
#calculate dist1 (line length within ellipse1)
mtx1 = EllipseLine_intersection(center = center1, radius = radius1, lineslop = lineslop)
dist1 = sqrt((mtx1["p1","x"] - mtx1["p2","x"])^2 + (mtx1["p1","y"] - mtx1["p2","y"])^2) / 2
#calculate dist2 (line length within ellipse2)
mtx2 = EllipseLine_intersection(center = center2, radius = radius2, lineslop = lineslop)
dist2 = sqrt((mtx2["p1","x"] - mtx2["p2","x"])^2 + (mtx2["p1","y"] - mtx2["p2","y"])^2) / 2
#calculate dist_center (distance between centers of two ellipses)
dist_center = sqrt((center1[1] - center2[1])^2 + (center1[2] - center2[2])^2)
dist_ratio = (dist_center + 0.01) / (dist1 + dist2 + 0.01)
dist_ratio
ED_mtx
intensity_matrix =
Spr1$intensity_matrix
Spr1$intensity_matrix
intensity_matrix = data.frame(Spr1 = Spr1$intensity_matrix,Spr2 = Spr2$intensity_matrix,)
intensity_matrix = data.frame(Spr1 = Spr1$intensity_matrix,Spr2 = Spr2$intensity_matrix)
intensity_matrix
Spr1$intercept_sigma2 + Spr1$slop_sigma2
sqrt(Spr1$intercept_sigma2 + Spr1$slop_sigma2 )
sigma_matrix = data.frame(Spr1 = sqrt(Spr1$intercept_sigma2 + Spr1$slop_sigma2),
Spr2 = sqrt(Spr2$intercept_sigma2 + Spr2$slop_sigma2))
sigma_matrix
intensity_matrix[fluor_i,"Spr1"]
intensity_matrix[1,"Spr1"]
i = 1
j = 2
fluor_i = fluors[i]
fluor_j = fluors[j]
intensity_matrix[fluor_i,"Spr1"]
fluor_i
intensity_matrix
intensity_matrix[fluor_i,"Spr1"]
intensity_matrix
intensity_matrix = data.frame(Spr1 = Spr1$intensity_matrix, Spr2 = Spr2$intensity_matrix)
intensity_matrix[fluor_i,"Spr1"]
intensity_matrix
intensity_matrix = data.frame(Spr1 = Spr1$intensity_matrix, Spr2 = Spr2$intensity_matrix)
intensity_matrix
sigma_matrix = data.frame(Spr1 = sqrt(Spr1$intercept_sigma2 + Spr1$slop_sigma2),
Spr2 = sqrt(Spr2$intercept_sigma2 + Spr2$slop_sigma2))
sigma_matrix
intensity_matrix = data.frame(Spr1 = c(Spr1$intensity_matrix), Spr2 = c(Spr2$intensity_matrix))
intensity_matrix
as.matrix(Spr1$intensity_matrix)
intensity_matrix = data.frame(Spr1 = as.matrix(Spr1$intensity_matrix), Spr2 = as.matrix(Spr2$intensity_matrix))
intensity_matrix
colnames(intensity_matrix) = c("Spr1","Spr2")
intensity_matrix
sigma_matrix = data.frame(Spr1 = sqrt(Spr1$intercept_sigma2 + Spr1$slop_sigma2),
Spr2 = sqrt(Spr2$intercept_sigma2 + Spr2$slop_sigma2))
sigma_matrix
intensity_matrix[fluor_i,"Spr1"]
center1 = c(intensity_matrix[fluor_i,"Spr1"],intensity_matrix[fluor_j,"Spr1"]) #x,y
center2 = c(intensity_matrix[fluor_i,"Spr2"],intensity_matrix[fluor_j,"Spr2"])
radius1 = c(sigma_matrix[fluor_i,"Spr1"],sigma_matrix[fluor_j,"Spr1"])
radius2 = c(sigma_matrix[fluor_i,"Spr2"],sigma_matrix[fluor_j,"Spr2"])
center1
center2
radius1
radius2
ED_mtx
Spr1
Spr2
#check if Spr1 and Spr2 have the same fluors
fluors = Spr1$fluors
if(any(fluors != Spr2$fluors)){
stop("The Spr1 and Spr2 do not have the same fluors.")
}else{
if(length(fluors) <= 1){
stop("At least 2 fluors are needed.")
}else{
intensity_matrix = data.frame(Spr1 = Spr1$intensity_matrix, Spr2 = Spr2$intensity_matrix)
colnames(intensity_matrix) = c("Spr1","Spr2")
sigma_matrix = data.frame(Spr1 = sqrt(Spr1$intercept_sigma2 + Spr1$slop_sigma2),
Spr2 = sqrt(Spr2$intercept_sigma2 + Spr2$slop_sigma2))
#prepare empty ED_mtx
ED_mtx = array(0, dim = c(length(fluors), length(fluors))) #(channel, scc)
colnames(ED_mtx) = fluors
rownames(ED_mtx) = fluors
for (i in 1:length(fluors)) {
for (j in 1:length(fluors)) {
fluor_i = fluors[i]
fluor_j = fluors[j]
#extract data
center1 = c(intensity_matrix[fluor_i,"Spr1"],intensity_matrix[fluor_j,"Spr1"]) #x,y
center2 = c(intensity_matrix[fluor_i,"Spr2"],intensity_matrix[fluor_j,"Spr2"])
radius1 = c(sigma_matrix[fluor_i,"Spr1"],sigma_matrix[fluor_j,"Spr1"])
radius2 = c(sigma_matrix[fluor_i,"Spr2"],sigma_matrix[fluor_j,"Spr2"])
#calculate lineslop
if(center1[1] == center1[2]){
lineslop = Inf
}else{
lineslop = (center1[2] - center2[2]) / (center1[1] - center2[1])
}
#calculate dist1 (line length within ellipse1)
mtx1 = EllipseLine_intersection(center = center1, radius = radius1, lineslop = lineslop)
dist1 = sqrt((mtx1["p1","x"] - mtx1["p2","x"])^2 + (mtx1["p1","y"] - mtx1["p2","y"])^2) / 2
#calculate dist2 (line length within ellipse2)
mtx2 = EllipseLine_intersection(center = center2, radius = radius2, lineslop = lineslop)
dist2 = sqrt((mtx2["p1","x"] - mtx2["p2","x"])^2 + (mtx2["p1","y"] - mtx2["p2","y"])^2) / 2
#calculate dist_center (distance between centers of two ellipses)
dist_center = sqrt((center1[1] - center2[1])^2 + (center1[2] - center2[2])^2)
dist_ratio = (dist_center + 0.01) / (dist1 + dist2 + 0.01) #if < 1, intersect
ED_mtx[fluor_i,fluor_j] = dist_ratio
}
}
}
}
ED_mtx
EstimateDistance = function(Spr1, Spr2){
#check if Spr1 and Spr2 have the same fluors
fluors = Spr1$fluors
if(any(fluors != Spr2$fluors)){
stop("The Spr1 and Spr2 do not have the same fluors.")
}else{
if(length(fluors) <= 1){
stop("At least 2 fluors are needed.")
}else{
intensity_matrix = data.frame(Spr1 = Spr1$intensity_matrix, Spr2 = Spr2$intensity_matrix)
colnames(intensity_matrix) = c("Spr1","Spr2")
sigma_matrix = data.frame(Spr1 = sqrt(Spr1$intercept_sigma2 + Spr1$slop_sigma2),
Spr2 = sqrt(Spr2$intercept_sigma2 + Spr2$slop_sigma2))
#prepare empty ED_mtx
ED_mtx = array(0, dim = c(length(fluors), length(fluors))) #(channel, scc)
colnames(ED_mtx) = fluors
rownames(ED_mtx) = fluors
for (i in 1:length(fluors)) {
for (j in 1:length(fluors)) {
fluor_i = fluors[i]
fluor_j = fluors[j]
#extract data
center1 = c(intensity_matrix[fluor_i,"Spr1"],intensity_matrix[fluor_j,"Spr1"]) #x,y
center2 = c(intensity_matrix[fluor_i,"Spr2"],intensity_matrix[fluor_j,"Spr2"])
radius1 = c(sigma_matrix[fluor_i,"Spr1"],sigma_matrix[fluor_j,"Spr1"])
radius2 = c(sigma_matrix[fluor_i,"Spr2"],sigma_matrix[fluor_j,"Spr2"])
#calculate lineslop
if(center1[1] == center1[2]){
lineslop = Inf
}else{
lineslop = (center1[2] - center2[2]) / (center1[1] - center2[1])
}
#calculate dist1 (line length within ellipse1)
mtx1 = EllipseLine_intersection(center = center1, radius = radius1, lineslop = lineslop)
dist1 = sqrt((mtx1["p1","x"] - mtx1["p2","x"])^2 + (mtx1["p1","y"] - mtx1["p2","y"])^2) / 2
#calculate dist2 (line length within ellipse2)
mtx2 = EllipseLine_intersection(center = center2, radius = radius2, lineslop = lineslop)
dist2 = sqrt((mtx2["p1","x"] - mtx2["p2","x"])^2 + (mtx2["p1","y"] - mtx2["p2","y"])^2) / 2
#calculate dist_center (distance between centers of two ellipses)
dist_center = sqrt((center1[1] - center2[1])^2 + (center1[2] - center2[2])^2)
dist_ratio = (dist_center + 0.01) / (dist1 + dist2 + 0.01) #if < 1, intersect
ED_mtx[fluor_i,fluor_j] = dist_ratio
}
}
}
}
return(ED_mtx)
}
SpreadDistance_mtx = EstimateDistance(Spr1, Spr2)
SpreadDistance_mtx
devtools::document()
# library(rmarkdown)
# library(patchwork)
#
devtools::install_github("xiangmingcai/USERM")
library(USERM)
#querySig
# library(grid)
Sig_info = querySig()
# Sig_info$id[c(32:38,41:42,44,46:48,50:54,58:62,8,9,12,14,18,24,25,26,63)]
Sig_mtx  = getSigMtx(ids = c(Sig_info$id[c(32:38,41:42,44,46:48,50:54,58:62,8,9,12,14,18,24,25,26,63)]))
SuprObj = CreateUserm(A = Sig_mtx)
#add ResObj into SuprObj
for (save_suf in colnames(Sig_mtx)) {
ResObj = getRes(id = save_suf)
SuprObj = AddRes2Userm(Res = ResObj, Userm = SuprObj)
}
SuprObj[["Scale_df"]][["min"]] = -100
SuprObj[["Scale_df"]][["max"]] = 1000
SuprObj[["Scale_df"]][["scale"]] = "Linear"
SuprObj[["Scale_df"]][["cofactor"]] = 10
#
#
# SuprObj = AddScale(Userm = SuprObj,fluor = colnames(Sig_mtx)[1],min = -100, max = 1000, scale = "Linear", cofactor = 10)# c("Linear","Log10","Arcsinh")
# SuprObj = AddScale(Userm = SuprObj,fluor = colnames(Sig_mtx)[2],min = -100, max = 1000, scale = "Log10", cofactor = 10)# c("Linear","Log10","Arcsinh")
# SuprObj = AddScale(Userm = SuprObj,fluor = colnames(Sig_mtx)[3],min = -100, max = 1000, scale = "Arcsinh", cofactor = 10)# c("Linear","Log10","Arcsinh")
# SuprObj = AddScale(Userm = SuprObj,fluor = colnames(Sig_mtx)[4],min = -100, max = 1000, scale = "Arcsinh", cofactor = 10)# c("Linear","Log10","Arcsinh")
SuprObj$Intensity_mtx[,1] = 100*c(1:length(SuprObj$fluors))
SuprObj$Intensity_mtx[,2] = 200*c(1:length(SuprObj$fluors))
SuprObj$Intensity_mtx[,3] = 300*c(1:length(SuprObj$fluors))
Spr1 = EstimateSpread(Userm = SuprObj,population_id = c("V1"))
Spr2 = EstimateSpread(Userm = SuprObj,population_id = c("V2"))
SpreadDistance_mtx = EstimateDistance(Spr1, Spr2)
SpreadDistance_mtx
View(SpreadDistance_mtx)
PredMultipleSpread(Userm = SuprObj,population_ids = c("V1","V2"))
devtools::document()

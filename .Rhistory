print(fluors_selected)
Sig_mtx  = getSigMtx(ids = fluors_selected)
dim(Sig_mtx)
UsermObj = CreateUserm(A = Sig_mtx)
#add ResObj into UsermObj
for (save_suf in colnames(Sig_mtx)) {
ResObj = getRes(id = save_suf)
UsermObj = AddRes2Userm(Res = ResObj, Userm = UsermObj)
}
PredOneSpread(Userm = UsermObj,population_id = c("V1"))
UsermObj$Intensity_mtx[,2] = UsermObj$Intensity_mtx[,1]
UsermObj$Intensity_mtx[,3] = UsermObj$Intensity_mtx[,1]
UsermObj$Intensity_mtx[20,2] = UsermObj$Intensity_mtx[20,1]*5
UsermObj$Intensity_mtx[20,3] = UsermObj$Intensity_mtx[20,1]*10
PredMultipleSpread(Userm = UsermObj,population_ids = c("V1","V2","V3"))
# PredOneSpread_update(Userm = UsermObj,population_id = c("V1"))
UsermObj$Intensity_mtx[,1] = 0
UsermObj$Intensity_mtx[,2] = UsermObj$Intensity_mtx[,1]
UsermObj$Intensity_mtx[,3] = UsermObj$Intensity_mtx[,1]
UsermObj$Intensity_mtx[20,2] = 100
UsermObj$Intensity_mtx[20,2] = UsermObj$Intensity_mtx[20,1]*5
UsermObj$Intensity_mtx[20,3] = UsermObj$Intensity_mtx[20,1]*10
# Step 4 matrics estimation and visualization
Coef_mtx = EstimateCoefMtx(Userm = UsermObj)
# pdf(file = "E:/ResidualModel/CoefMtx.pdf",width = 10,height = 10)
Vis_Mtx(mat = Coef_mtx,mincolor = "white",midcolor = "white", maxcolor = "#95ABDB",
max = 20,mid = 10,min = 0,legend_name = "Coef",
title = "Coefficient of residual model matrix (Coef Matrix) (row spread into column)")
# devtools::install_github("xiangmingcai/USERM")
library(USERM)
# Step 1 querySig
Sig_info = querySig()
head(Sig_info)
# Step 2 Select fluors and create UsermObj
# fluors_selected = c(Sig_info$id[c(32:38,41:42,46:48,50:54,8,9,12,63)])#,58:62,8,9,12,14,18,24,25,26,63
fluors_selected = c(Sig_info$id[c(149,201,150,151,
152,153,154,155,
156,157,158,159,
160,161,162,163,
189,200,196,199,138)])#,58:62,8,9,12,14,18,24,25,26,63
print(fluors_selected)
Sig_mtx  = getSigMtx(ids = fluors_selected)
dim(Sig_mtx)
UsermObj = CreateUserm(A = Sig_mtx)
#add ResObj into UsermObj
for (save_suf in colnames(Sig_mtx)) {
ResObj = getRes(id = save_suf)
UsermObj = AddRes2Userm(Res = ResObj, Userm = UsermObj)
}
#create 3 populations with all zero fluroescence intensities
UsermObj$Intensity_mtx[,1] = 0
UsermObj$Intensity_mtx[,2] = UsermObj$Intensity_mtx[,1]
UsermObj$Intensity_mtx[,3] = UsermObj$Intensity_mtx[,1]
# assign 100, 500, 1000 to the PECy7 intensities of these 3 populations
UsermObj$Intensity_mtx[20,1] = 100
UsermObj$Intensity_mtx[20,2] = 500
UsermObj$Intensity_mtx[20,3] = 1000
View(UsermObj)
UsermObj[["Intensity_mtx"]]
print(UsermObj[["Intensity_mtx"]])
PredMultipleSpread(Userm = UsermObj,population_ids = c("V1","V2","V3"))
PredOneSpread(Userm = UsermObj,population_id = c("V1"))
# pdf(file = "E:/ResidualModel/CoefMtx.pdf",width = 10,height = 10)
Vis_Mtx(mat = UsermObj$A,mincolor = "white",midcolor = "#D03E4C", maxcolor = "#B02B38",
max = 1,mid = 0.5,min = 0,legend_name = "Signal",
title = "Signature matrix")
# pdf(file = "E:/ResidualModel/CoefMtx.pdf",width = 10,height = 10)
Vis_Mtx(mat = t(UsermObj$A),mincolor = "white",midcolor = "#D03E4C", maxcolor = "#B02B38",
max = 1,mid = 0.5,min = 0,legend_name = "Signal",
title = "Signature matrix")
# pdf(file = "E:/ResidualModel/CoefMtx.pdf",width = 10,height = 10)
Vis_Mtx(mat = UsermObj$A,mincolor = "white",midcolor = "#D03E4C", maxcolor = "#B02B38",
max = 1,mid = 0.5,min = 0,legend_name = "Signal",
title = "Signature matrix")
pdf(file = "E:/ResidualModel/Signature matrix.pdf",width = 6,height = 10)
Vis_Mtx(mat = UsermObj$A,mincolor = "white",midcolor = "#D03E4C", maxcolor = "#B02B38",
max = 1,mid = 0.5,min = 0,legend_name = "Signal",
title = "Signature matrix")
dev.off()
pdf(file = "E:/ResidualModel/Signature matrix.pdf",width = 6,height = 12)
Vis_Mtx(mat = UsermObj$A,mincolor = "white",midcolor = "#D03E4C", maxcolor = "#B02B38",
max = 1,mid = 0.5,min = 0,legend_name = "Signal",
title = "Signature matrix")
dev.off()
A = UsermObj$A
library(MASS)
pinv_A = pinv(A)
pinv_A = ginv(A)
Vis_Mtx(mat = pinv_A,mincolor = "white",midcolor = "#D03E4C", maxcolor = "#B02B38",
max = 1,mid = 0.5,min = 0,legend_name = "Value",
title = "Pseudo-inverse matrix")
Vis_Mtx(mat = pinv_A,mincolor = "#95ABDB",midcolor = "white", maxcolor = "#B02B38",
max = 1,mid = 0,min = -1,legend_name = "Value",
title = "Pseudo-inverse matrix")
colnames(A_pinv) = rownames(A)
rownames(A_pinv) = colnames(A)
library(MASS)
A_pinv = ginv(A)
colnames(A_pinv) = rownames(A)
rownames(A_pinv) = colnames(A)
Vis_Mtx(mat = A_pinv,mincolor = "#95ABDB",midcolor = "white", maxcolor = "#B02B38",
max = 1,mid = 0,min = -1,legend_name = "Value",
title = "Pseudo-inverse matrix")
A_pinv_t = t(A_pinv)
A_pinv_t = t(A_pinv)
Vis_Mtx(mat = A_pinv_t,mincolor = "#95ABDB",midcolor = "white", maxcolor = "#B02B38",
max = 1,mid = 0,min = -1,legend_name = "Value",
title = "transpose of Pseudo-inverse matrix")
dev.off()
A_pinv_t = t(A_pinv)
pdf(file = "E:/ResidualModel/transpose pinv matrix.pdf",width = 6,height = 12)
Vis_Mtx(mat = A_pinv_t,mincolor = "#95ABDB",midcolor = "white", maxcolor = "#B02B38",
max = 1,mid = 0,min = -1,legend_name = "Value",
title = "transpose of Pseudo-inverse matrix")
dev.off()
Vis_Mtx(mat = A_pinv,mincolor = "#95ABDB",midcolor = "white", maxcolor = "#B02B38",
max = 1,mid = 0,min = -1,legend_name = "Value",
title = "Pseudo-inverse matrix")
slop_mtx = UsermObj$Res$SCC3_Cell_PECy7_CD4$slopMtx
View(slop_mtx)
slop_mtx = UsermObj$Res$SCC3_Cell_PECy7_CD4$slopMtx
Vis_Mtx(mat = slop_mtx,mincolor = "#95ABDB",midcolor = "white", maxcolor = "#B02B38",
max = 1,mid = 0,min = -1,legend_name = "beta",
title = "slop matrix")
dev.off()
pdf(file = "E:/ResidualModel/slop matrix.pdf",width = 12,height = 12)
slop_mtx = UsermObj$Res$SCC3_Cell_PECy7_CD4$slopMtx
Vis_Mtx(mat = slop_mtx,mincolor = "#95ABDB",midcolor = "white", maxcolor = "#B02B38",
max = 1,mid = 0,min = -1,legend_name = "beta",
title = "slop matrix")
dev.off()
View(A_pinv)
A_pinv["SCC3_Cell_PECy7_CD4",]
A_pinv["SCC3_Cell_PECy7_CD4",]%o%A_pinv["SCC3_Cell_PECy7_CD4",]
A_pinv["SCC3_Cell_PECy7_CD4",1:2]
A_pinv["SCC3_Cell_PECy7_CD4",1:2]%o%A_pinv["SCC3_Cell_PECy7_CD4",1:2]
(-0.01655523 )*(-0.01655523 )
(-0.01655523 )*(-0.01363050 )
(-0.01363050 )*(-0.01363050 )
weight_mtx = A_pinv["SCC3_Cell_PECy7_CD4",]%o%A_pinv["SCC3_Cell_PECy7_CD4",]
Vis_Mtx(mat = weight_mtx,mincolor = "#95ABDB",midcolor = "white", maxcolor = "#B02B38",
max = 1,mid = 0,min = -1,legend_name = "beta",
title = "weight matrix")
dev.off()
weight_mtx = A_pinv["SCC3_Cell_PECy7_CD4",]%o%A_pinv["SCC3_Cell_PECy7_CD4",]
pdf(file = "E:/ResidualModel/weight matrix.pdf",width = 12,height = 12)
Vis_Mtx(mat = weight_mtx,mincolor = "#95ABDB",midcolor = "white", maxcolor = "#B02B38",
max = 1,mid = 0,min = -1,legend_name = "weight",
title = "weight matrix")
dev.off()
b1 <- matrix(c(1, 2, 3, 4), nrow = 2)
b2 <- matrix(c(5, 6, 7, 8), nrow = 2)
b1
b2
# 计算哈达玛积
b3 <- b1 * b2
b3
weighted_slope_mtx = weight_mtx * slop_mtx
Vis_Mtx(mat = weighted_slope_mtx,mincolor = "#95ABDB",midcolor = "white", maxcolor = "#B02B38",
max = 1,mid = 0,min = -1,legend_name = "beta",
title = "weighted slop matrix")
Vis_Mtx(mat = weighted_slope_mtx,mincolor = "#95ABDB",midcolor = "white", maxcolor = "#B02B38",
max = 10,mid = 0,min = -10,legend_name = "value",
title = "weighted slop matrix")
pdf(file = "E:/ResidualModel/weight slope matrix.pdf",width = 12,height = 12)
Vis_Mtx(mat = weighted_slope_mtx,mincolor = "#95ABDB",midcolor = "white", maxcolor = "#B02B38",
max = 10,mid = 0,min = -10,legend_name = "value",
title = "weighted slop matrix")
dev.off()
sum(weighted_slope_mtx)
Vis_Mtx(mat = A_pinv,mincolor = "#95ABDB",midcolor = "white", maxcolor = "#B02B38",
max = 1,mid = 0,min = -1,legend_name = "Value",
title = "Pseudo-inverse matrix")
dev.off()
weight_mtx = A_pinv["SCC3_Cell_BV510_CD4",]%o%A_pinv["SCC3_Cell_BV510_CD4",]
pdf(file = "E:/ResidualModel/weight matrix.pdf",width = 12,height = 12)
Vis_Mtx(mat = weight_mtx,mincolor = "#95ABDB",midcolor = "white", maxcolor = "#B02B38",
max = 1,mid = 0,min = -1,legend_name = "weight",
title = "weight matrix")
dev.off()
weighted_slope_mtx = weight_mtx * slop_mtx
pdf(file = "E:/ResidualModel/weight slope matrix.pdf",width = 12,height = 12)
Vis_Mtx(mat = weighted_slope_mtx,mincolor = "#95ABDB",midcolor = "white", maxcolor = "#B02B38",
max = 10,mid = 0,min = -10,legend_name = "value",
title = "weighted slop matrix")
dev.off()
sum(weighted_slope_mtx)
ResObj = UsermObj$Res$SCC3_Cell_PECy7_CD4
ResObj$detectors
checkRes_covScatter(Res = ResObj,
detector1 = "B13-A",
detector2 = "B14-A")
checkSig_linePlot(id = SCC3_Cell_PECy7_CD4)
checkSig_linePlot(id = "SCC3_Cell_PECy7_CD4")
Similarity_mtx = EstimateSimilarityMtx(A = UsermObj$A)
# pdf(file = "E:/ResidualModel/SimilarityMtx.pdf",width = 10,height = 10)
Vis_Mtx(mat = Similarity_mtx,mincolor = "white",midcolor = "white", maxcolor = "#95ABDB",
max = 1,mid = 0.8,min = 0,legend_name = "Cosine",
title = "Cosine similarity matrix")
Hotspot_mtx = EstimateHotspotMtx(A = UsermObj$A)
# pdf(file = "E:/ResidualModel/HotspotMtx.pdf",width = 10,height = 10)
Vis_Mtx(mat = Hotspot_mtx,mincolor = "white",midcolor = "white", maxcolor = "#95ABDB",
max = 2,mid = 1,min = 0,legend_name = "Hotspot",
title = "Hotspot matrix")
devtools::document()
devtools::document()
devtools::install_github("xiangmingcai/USERM")
# devtools::install_github("xiangmingcai/USERM")
library(USERM)
# Step 1 querySig
Sig_info = querySig()
head(Sig_info)
fluor_to_check = Sig_info$id[3]
print(fluor_to_check)
checkSig_linePlot(id = fluor_to_check)
ResObj = getRes(id = fluor_to_check)
checkRes_slopMtx(Res = ResObj)
checkRes_interceptMtx(Res = ResObj)
print(ResObj$bin_mids)
checkRes_covMtx(Res = ResObj,bin=3)
ResObj$detectors
checkRes_covScatter(Res = ResObj,
detector1 = ResObj$detectors[1],
detector2 = ResObj$detectors[2])
# Step 2 Select fluors and create UsermObj
# fluors_selected = c(Sig_info$id[c(32:38,41:42,46:48,50:54,8,9,12,63)])#,58:62,8,9,12,14,18,24,25,26,63
fluors_selected = c(Sig_info$id[c(149,201,150,151,
152,153,154,155,
156,157,158,159,
160,161,162,163,
189,200,196,199,138)])#,58:62,8,9,12,14,18,24,25,26,63
print(fluors_selected)
Sig_mtx  = getSigMtx(ids = fluors_selected)
dim(Sig_mtx)
UsermObj = CreateUserm(A = Sig_mtx)
#add ResObj into UsermObj
for (save_suf in colnames(Sig_mtx)) {
ResObj = getRes(id = save_suf)
UsermObj = AddRes2Userm(Res = ResObj, Userm = UsermObj)
}
# Step 3 Make prediction (optional)
UsermObj$Scale_df$min = -2000
UsermObj$Scale_df$max = 5000
PredOneSpread(Userm = UsermObj,population_id = c("V1"))
UsermObj$Intensity_mtx[,2] = UsermObj$Intensity_mtx[,1]
UsermObj$Intensity_mtx[,3] = UsermObj$Intensity_mtx[,1]
# assign 100, 500, 1000 to the PECy7 intensities of these 3 populations
UsermObj$Intensity_mtx[20,1] = 100
UsermObj$Intensity_mtx[20,2] = 500
UsermObj$Intensity_mtx[20,3] = 1000
UsermObj$Intensity_mtx[,2] = 200*c(1:length(UsermObj$fluors))
UsermObj$Intensity_mtx[,3] = 300*c(1:length(UsermObj$fluors))
names(UsermObj$Intensity_mtx) = c("V1","V2","V3")
PredMultipleSpread(Userm = UsermObj,population_ids = c("V1","V2","V3"))
# Step 4 matrics estimation and visualization
Coef_mtx = EstimateCoefMtx(Userm = UsermObj)
# pdf(file = "E:/ResidualModel/CoefMtx.pdf",width = 10,height = 10)
Vis_Mtx(mat = Coef_mtx,mincolor = "white",midcolor = "white", maxcolor = "#95ABDB",
max = 20,mid = 10,min = 0,legend_name = "Coef",
title = "Coefficient of residual model matrix (Coef Matrix) (row spread into column)")
Hotspot_mtx = EstimateHotspotMtx(A = UsermObj$A)
# pdf(file = "E:/ResidualModel/HotspotMtx.pdf",width = 10,height = 10)
Vis_Mtx(mat = Hotspot_mtx,mincolor = "white",midcolor = "white", maxcolor = "#95ABDB",
max = 2,mid = 1,min = 0,legend_name = "Hotspot",
title = "Hotspot matrix")
Similarity_mtx = EstimateSimilarityMtx(A = UsermObj$A)
# pdf(file = "E:/ResidualModel/SimilarityMtx.pdf",width = 10,height = 10)
Vis_Mtx(mat = Similarity_mtx,mincolor = "white",midcolor = "white", maxcolor = "#95ABDB",
max = 1,mid = 0.8,min = 0,legend_name = "Cosine",
title = "Cosine similarity matrix")
Spr1 = EstimateSpread(Userm = UsermObj,population_id = c("P1"))
Spr2 = EstimateSpread(Userm = UsermObj,population_id = c("P2"))
SpreadDistance_mtx = EstimateDistance(Spr1, Spr2)
Vis_Mtx(mat = SpreadDistance_mtx,mincolor = "darkred",midcolor = "white", maxcolor = "white",max = 1.5,mid = 1,min = 0,title = "Spread Distance matrix")
A = UsermObj$A
pdf(file = "E:/ResidualModel/Signature matrix.pdf",width = 6,height = 12)
Vis_Mtx(mat = A,mincolor = "white",midcolor = "#D03E4C", maxcolor = "#B02B38",
max = 1,mid = 0.5,min = 0,legend_name = "Signal",
title = "Signature matrix")
dev.off()
dev.off()
dev.off()
# devtools::install_github("xiangmingcai/USERM")
library(USERM)
# #read in SCC fcs
library(flowCore)
library(MASS)
library(GateData)
library(ggplot2)
# library(reshape2)
# library(progress)
library(shiny)
# library(DT)
library(dplyr)
library(ComplexHeatmap)
library(circlize)
# devtools::install_github("xiangmingcai/USERM")
library(USERM)
# devtools::install_github("xiangmingcai/USERM")
library(USERM)
custom_dir = "E:/MyFolder"
#step 1
data = read.FCS("E:/Data/SCC_Cell_CD2_SB780 Run 1 20251024102726.fcs")
library(flowCore)
#step 1
data = read.FCS("E:/Data/SCC_Cell_CD2_SB780 Run 1 20251024102726.fcs")
desc = data@parameters@data$desc # "desc" or "name" are used for different insruments. Ues the one with correct detector names.
priont(desc)
print(desc)
print(head(desc))
print(head(data@parameters@data$desc))
print(head(data@parameters@data$name))
data = exprs(data)
data = as.data.frame(data)
colnames(data) = desc
head(data)
peak_channel = '405nm - 770/LP-A' #use public resource (e.g. fluorofinder) to find the peak channel of your SCC.
save_suf = "SCCcustom_Cell_CD2_SB780"
#it is recommended to follow the naming pattern.
#There are 4 elements in the name, which are seperated by underscore.
#The first is "batch" element. The preprocessed scc use "SCC1", "SCC2", and so on to annotate SCCs acquired in distinct batches.
#You can use "SCCcustom" to distinguish custom fluorescence and preprocessed fluorescence. You can also use others that make sense to you.
#The second is "type" element. Now We only have "Cell" and "Bead".
#The third is "PrimaryName". Normally we put target of the fluorescence antibody here.
#The last is "SecondaryName", Normally we put fluroescence of the antibody here.
#Please avoid using space or underscore in these elements.
PrimaryName = "CD2"
SecondaryName = "SB780"
# devtools::install_github("xiangmingcai/GateData")
library(GateData)
dir.create(paste0(custom_dir,"/sig"))
dir.create(paste0(custom_dir,"/res"))
data$gate0 = TRUE
#gate singlets if need
gate1<-PolygonGating(df=data, x_col= "488 FSC-A", y_col= "488 FSC-H", feature_col= "488 FSC-A",
parentgate_col= "gate0", newgate_col= "gate1",canvas_width=800, canvas_height=400)
#sample cells. You may modify code here to sample specific set for rare markers.
data = sample_n(data, 20000)
library(dplyr)
#sample cells. You may modify code here to sample specific set for rare markers.
data = sample_n(data, 20000)
#gate singlets if need
gate1<-PolygonGating(df=data, x_col= "488 FSC-A", y_col= "488 FSC-H", feature_col= "488 FSC-A",
parentgate_col= "gate0", newgate_col= "gate1",canvas_width=800, canvas_height=400)
data <-GateDecider(gate = gate1, df = data)
gate2<-PolygonGating(df=data, x_col= "488 SSC-A", y_col= "488 SSC-H", feature_col= "488 SSC-A",
parentgate_col= "gate1", newgate_col= "gate2",canvas_width=800, canvas_height=400)
data <-GateDecider(gate = gate2, df = data)
gate3<-PolygonGating(df=data, x_col= "488 SSC-A", y_col= "488 FSC-A", feature_col= "488 SSC-A",
parentgate_col= "gate2", newgate_col= "gate3",canvas_width=2000, canvas_height=2000)
data <-GateDecider(gate = gate3, df = data)
data = data[data$gate3,]
gate_pos<-PolygonGating(df=data, x_col= peak_channel, y_col= "488 SSC-A", feature_col= "488 SSC-A",
parentgate_col= "gate3", newgate_col= "gate_pos",canvas_width=800, canvas_height=400,
title_text = "Gate positive population")
data <-GateDecider(gate = gate_pos, df = data)
gate_neg<-PolygonGating(df=data, x_col= peak_channel, y_col= "488 SSC-A", feature_col= "488 SSC-A",
parentgate_col= "gate3", newgate_col= "gate_neg",canvas_width=800, canvas_height=400,
title_text = "Gate negative population")
data <-GateDecider(gate = gate_neg, df = data)
gate3<-PolygonGating(df=data, x_col= "488 SSC-A", y_col= "488 FSC-A", feature_col= "488 SSC-A",
parentgate_col= "gate2", newgate_col= "gate3",canvas_width=1500, canvas_height=1500,
title_text = "Gate target population")
table(data$gate_pos)
table(data$gate_neg)
data_pos = data[data$gate_pos,]
data_neg = data[data$gate_neg,]
colnames(data)
#step 1.4 extract signatures
colnames(data)
colnames(data)[c(28)]
seq(from=0, to=20, by=4)
seq(from=28, to=126, by=2)
colnames(data)[seq(from=28, to=126, by=2)]
colnames(data)[seq(from=28, to=128, by=2)]
#step 1.4 extract signatures
#Select detectors. Please select only the detectors for unmixing
colnames(data)
cols = colnames(data)[seq(from=28, to=128, by=2)]
print(cols)
Sig = ExtractSig(df_pos = data_pos,df_neg = data_neg,
cols = cols, method = "median",
PrimaryName = PrimaryName,
SecondaryName = SecondaryName,
id = save_suf,
instrument = "Xenith",
Source = "YourName",
Note = NA)
#you may briefly check the signature
df <- data.frame(Detector = names(Sig$Signature),Signal = as.numeric(Sig$Signature))
ggplot(df, aes(x = Detector, y = Signal, group = 1)) +
geom_line(color = "steelblue", size = 1) +
geom_point(color = "darkred", size = 2) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
labs(title = save_suf,
x = "Detector",
y = "Signal")
library(ggplot2)
ggplot(df, aes(x = Detector, y = Signal, group = 1)) +
geom_line(color = "steelblue", size = 1) +
geom_point(color = "darkred", size = 2) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
labs(title = save_suf,
x = "Detector",
y = "Signal")
ggplot(df, aes(x = Detector, y = Signal, group = 1)) +
geom_line(color = "steelblue", linewidth = 1) +
geom_point(color = "darkred", size = 2) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
labs(title = save_suf,
x = "Detector",
y = "Signal")
#step 1.5 add signatures to Custom_Sig_list
#For first SCC
Custom_Sig_list = list()
#If you already have a Custom_Sig_list
Custom_Sig_list = readRDS(paste0(custom_dir,"/sig/Custom_Sig_list.rds"))
#step 1.5 add signatures to Custom_Sig_list
#Read in Custom_Sig_list
#For first SCC (that means you do not have a Custom_Sig_list yet)
Custom_Sig_list = list()
#If you already have a Custom_Sig_list
Custom_Sig_list = readRDS(paste0(custom_dir,"/sig/Custom_Sig_list.rds"))
#add signatures to Custom_Sig_list
Custom_Sig_list[[length(Custom_Sig_list)+1]] = Sig
names(Custom_Sig_list)[length(Custom_Sig_list)] = Custom_Sig_list[[length(Custom_Sig_list)]]$id
#save updated Custom_Sig_list
saveRDS(Custom_Sig_list, file = paste0(custom_dir,"/sig/Custom_Sig_list.rds"))
data = read.FCS("E:/Data/unstained_1 Run 1 20251024100712.fcs")
print(head(data@parameters@data$desc))
print(head(data@parameters@data$name))
desc = data@parameters@data$desc # "desc" or "name" are used for different insruments. Ues the one with correct detector names.
data = exprs(data)
data = as.data.frame(data)
colnames(data) = desc
head(data)
save_suf = "SCCcustom_Cell_AF_AF"
PrimaryName = "AF"
SecondaryName = "AF"
# 1. sample cells.
#You may modify code here to sample specific set for rare markers.
data$gate0 = TRUE
data = sample_n(data, 20000)
# 2. gate singlets if need
#You can change the FSC and SSC names for specific instrument.
# use colnames(data) to find available paramters
# colnames(data)
gate1<-PolygonGating(df=data, x_col= "488 FSC-A", y_col= "488 FSC-H", feature_col= "488 FSC-A",
parentgate_col= "gate0", newgate_col= "gate1",canvas_width=800, canvas_height=400,
title_text = "Gate singlets")
data <-GateDecider(gate = gate1, df = data)
gate2<-PolygonGating(df=data, x_col= "488 SSC-A", y_col= "488 SSC-H", feature_col= "488 SSC-A",
parentgate_col= "gate1", newgate_col= "gate2",canvas_width=800, canvas_height=400,
title_text = "Gate singlets")
data <-GateDecider(gate = gate2, df = data)
# 3. gate target population (e.g. lymphocytes)
gate3<-PolygonGating(df=data, x_col= "488 SSC-A", y_col= "488 FSC-A", feature_col= "488 SSC-A",
parentgate_col= "gate2", newgate_col= "gate3",canvas_width=1500, canvas_height=1500,
title_text = "Gate target population")
data <-GateDecider(gate = gate3, df = data)
# 4. gate positive and negative populations.
#For autofluorescence, randomly gate a negative populaiton and assign zero to it.
data = data[data$gate3,]
gate_pos<-PolygonGating(df=data, x_col= peak_channel, y_col= "488 SSC-A", feature_col= "488 SSC-A",
parentgate_col= "gate3", newgate_col= "gate_pos",canvas_width=800, canvas_height=400,
title_text = "Gate positive population")
data <-GateDecider(gate = gate_pos, df = data)
gate_neg<-PolygonGating(df=data, x_col= peak_channel, y_col= "488 SSC-A", feature_col= "488 SSC-A",
parentgate_col= "gate3", newgate_col= "gate_neg",canvas_width=800, canvas_height=400,
title_text = "Gate negative population")
data <-GateDecider(gate = gate_neg, df = data)
table(data$gate_pos)
table(data$gate_neg)
data_pos = data[data$gate_pos,]
data_neg = data[data$gate_neg,]
# For autofluorescence, assign zero to data_neg
data_neg[,] <- 0
#step 1.4 extract signatures
#Select detectors. Please select only the detectors for unmixing
colnames(data)
cols = colnames(data)[seq(from=28, to=128, by=2)]
print(cols)
Sig = ExtractSig(df_pos = data_pos,df_neg = data_neg,
cols = cols, method = "median",
PrimaryName = PrimaryName,
SecondaryName = SecondaryName,
id = save_suf,
instrument = "Xenith",
Source = "YourName",
Note = NA)
#you may briefly check the signature
df <- data.frame(Detector = names(Sig$Signature),Signal = as.numeric(Sig$Signature))
ggplot(df, aes(x = Detector, y = Signal, group = 1)) +
geom_line(color = "steelblue", linewidth = 1) +
geom_point(color = "darkred", size = 2) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
labs(title = save_suf,
x = "Detector",
y = "Signal")
#If you already have a Custom_Sig_list
Custom_Sig_list = readRDS(paste0(custom_dir,"/sig/Custom_Sig_list.rds"))
# 2. add signatures to Custom_Sig_list
Custom_Sig_list[[length(Custom_Sig_list)+1]] = Sig
names(Custom_Sig_list)[length(Custom_Sig_list)] = Custom_Sig_list[[length(Custom_Sig_list)]]$id
# 3. save updated Custom_Sig_list
saveRDS(Custom_Sig_list, file = paste0(custom_dir,"/sig/Custom_Sig_list.rds"))
devtools::install_github("xiangmingcai/USERM@dev")
devtools::document()

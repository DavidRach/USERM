parentgate_col= "gate1", newgate_col= "gate2",canvas_width=800, canvas_height=400)
data <-GateDecider(gate = gate2, df = data)
gate3<-PolygonGating(df=data, x_col= "488 FSC-A", y_col= "488 SSC-A", feature_col= "488 SSC-A",
parentgate_col= "gate2", newgate_col= "gate3",canvas_width=2000, canvas_height=2000)
data <-GateDecider(gate = gate3, df = data)
data = data_backup
data <-GateDecider(gate = gate1, df = data)
data <-GateDecider(gate = gate2, df = data)
data <-GateDecider(gate = gate3, df = data)
data = data[data$gate3,]
#unmix with target_fluor and AF
data = data[,rownames(Sig_df)]
R = as.matrix(data)
A = Sig_mtx[,c(idx_target_fluor,idx_AF_fluor), drop = FALSE]
A_pinv = ginv(A)
B = R %*% A
colnames(Sig_mtx)[idx_target_fluor]
data = cbind(data,B)
data$gate0 = TRUE
#gate normal samples
data = data[(data[,colnames(Sig_mtx)[idx_target_fluor]] <
quantile(data[,colnames(Sig_mtx)[idx_target_fluor]],0.99)),]
data = data[(data[,colnames(Sig_mtx)[idx_target_fluor]] >
quantile(data[,colnames(Sig_mtx)[idx_target_fluor]],0.01)),]
data_backup = data
data = sample_n(data, 20000)
data = data[(data[,colnames(Sig_mtx)[idx_AF_fluor]] < quantile(data[,colnames(Sig_mtx)[idx_AF_fluor]],0.999)),]
gate_normal<-PolygonGating(df=data, x_col= colnames(Sig_mtx)[idx_target_fluor],
y_col= colnames(Sig_mtx)[idx_AF_fluor],
feature_col= colnames(Sig_mtx)[idx_target_fluor],
parentgate_col= "gate0", newgate_col= "gate_normal",canvas_width=800, canvas_height=400)
data = data_backup
data = GateDecider(gate = gate_normal, df = data)
data = data[data$gate_normal,rownames(Sig_df)]
#calculate residuals
R = as.matrix(data)
A = Sig_mtx[,c(idx_target_fluor), drop = FALSE]
ResObj = CreateRes(id = colnames(Sig_mtx)[idx_target_fluor], R = R, A = A)
ResObj = SlopEstimation(ResObj, bin_num = 20)
col_fun = colorRamp2(c(-1, 0, 1), c("blue", "white", "red"))
Heatmap(ResObj$slopMtx,col = col_fun, cluster_rows = FALSE,cluster_columns = FALSE)
#SCC_Cell_CD3_BV510 ####
data = read.FCS(paste0(data_dir,"/SCC_Cell_CD3 Run 1 20241112112836.fcs"))
save_suf = "SCC_Cell_CD3_BV510"
idx_target_fluor = 34
idx_AF_fluor = 4
#RES ####
colnames(Sig_mtx)[idx_target_fluor]
#the following code applies for all SCCs
desc = data@parameters@data$desc
data = exprs(data)
data = as.data.frame(data)
colnames(data) = desc
colnames(data)
#gate clean data for estimation
#gate singlets
data$gate0 = TRUE
data_backup = data
data = sample_n(data, 20000)
gate1<-PolygonGating(df=data, x_col= "488 FSC-A", y_col= "488 FSC-H", feature_col= "488 FSC-A",
parentgate_col= "gate0", newgate_col= "gate1",canvas_width=800, canvas_height=400)
data <-GateDecider(gate = gate1, df = data)
gate2<-PolygonGating(df=data, x_col= "488 SSC-A", y_col= "488 SSC-H", feature_col= "488 SSC-A",
parentgate_col= "gate1", newgate_col= "gate2",canvas_width=800, canvas_height=400)
data <-GateDecider(gate = gate2, df = data)
gate3<-PolygonGating(df=data, x_col= "488 FSC-A", y_col= "488 SSC-A", feature_col= "488 SSC-A",
parentgate_col= "gate2", newgate_col= "gate3",canvas_width=2000, canvas_height=2000)
data <-GateDecider(gate = gate3, df = data)
data = data_backup
data <-GateDecider(gate = gate1, df = data)
data <-GateDecider(gate = gate2, df = data)
data <-GateDecider(gate = gate3, df = data)
data = data[data$gate3,]
#unmix with target_fluor and AF
data = data[,rownames(Sig_df)]
R = as.matrix(data)
A = Sig_mtx[,c(idx_target_fluor,idx_AF_fluor), drop = FALSE]
A_pinv = ginv(A)
B = R %*% A
colnames(Sig_mtx)[idx_target_fluor]
data = cbind(data,B)
data$gate0 = TRUE
#gate normal samples
data = data[(data[,colnames(Sig_mtx)[idx_target_fluor]] <
quantile(data[,colnames(Sig_mtx)[idx_target_fluor]],0.99)),]
data = data[(data[,colnames(Sig_mtx)[idx_target_fluor]] >
quantile(data[,colnames(Sig_mtx)[idx_target_fluor]],0.01)),]
data_backup = data
data = sample_n(data, 20000)
data = data[(data[,colnames(Sig_mtx)[idx_AF_fluor]] < quantile(data[,colnames(Sig_mtx)[idx_AF_fluor]],0.999)),]
gate_normal<-PolygonGating(df=data, x_col= colnames(Sig_mtx)[idx_target_fluor],
y_col= colnames(Sig_mtx)[idx_AF_fluor],
feature_col= colnames(Sig_mtx)[idx_target_fluor],
parentgate_col= "gate0", newgate_col= "gate_normal",canvas_width=800, canvas_height=400)
data = data_backup
data = GateDecider(gate = gate_normal, df = data)
data = data[data$gate_normal,rownames(Sig_df)]
#calculate residuals
R = as.matrix(data)
A = Sig_mtx[,c(idx_target_fluor), drop = FALSE]
ResObj = CreateRes(id = colnames(Sig_mtx)[idx_target_fluor], R = R, A = A)
ResObj = SlopEstimation(ResObj, bin_num = 50)
A
col_fun = colorRamp2(c(-1, 0, 1), c("blue", "white", "red"))
Heatmap(ResObj$slopMtx,col = col_fun, cluster_rows = FALSE,cluster_columns = FALSE)
df <- data.frame(Detector = rownames(A),Signal = as.numeric(A))
ggplot(df, aes(x = Detector, y = Signal, group = 1)) +
geom_line(color = "steelblue", size = 1) +
geom_point(color = "darkred", size = 2) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
labs(title = save_suf,
x = "Detector",
y = "Signal")
Heatmap(ResObj$slopMtx,col = col_fun, cluster_rows = FALSE,cluster_columns = FALSE,
cell_fun = function(j, i, x, y, width, height, fill) {
grid.text(sprintf("%.1f", small_mat[i, j]), x, y, gp = gpar(fontsize = 10))
})
Heatmap(ResObj$slopMtx,col = col_fun, cluster_rows = FALSE,cluster_columns = FALSE,
cell_fun = function(j, i, x, y, width, height, fill) {
grid.text(sprintf("%.1f", ResObj$slopMtx[i, j]), x, y, gp = gpar(fontsize = 10))
})
Heatmap(ResObj$slopMtx,col = col_fun, cluster_rows = FALSE,cluster_columns = FALSE,
cell_fun = function(j, i, x, y, width, height, fill) {
grid.text(sprintf("%.2f", ResObj$slopMtx[i, j]), x, y, gp = gpar(fontsize = 6))
})
# data = data[(data[,colnames(Sig_mtx)[idx_AF_fluor]] < quantile(data[,colnames(Sig_mtx)[idx_AF_fluor]],0.999)),]
gate_normal<-PolygonGating(df=data, x_col= colnames(Sig_mtx)[idx_target_fluor],
y_col= colnames(Sig_mtx)[idx_AF_fluor],
feature_col= colnames(Sig_mtx)[idx_target_fluor],
parentgate_col= "gate0", newgate_col= "gate_normal",canvas_width=800, canvas_height=400)
#RES ####
colnames(Sig_mtx)[idx_target_fluor]
colnames(Sig_mtx)[idx_AF_fluor]
df <- data.frame(Detector = rownames(Sig_mtx[,c(idx_AF_fluor), drop = FALSE]),
Signal = as.numeric(Sig_mtx[,c(idx_AF_fluor), drop = FALSE]))
ggplot(df, aes(x = Detector, y = Signal, group = 1)) +
geom_line(color = "steelblue", size = 1) +
geom_point(color = "darkred", size = 2) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
labs(title = save_suf,
x = "Detector",
y = "Signal")
data = read.FCS(paste0(data_dir,"/SCC_Cell_CD3 Run 1 20241112112836.fcs"))
save_suf = "SCC_Cell_CD3_BV510"
idx_target_fluor = 34
idx_AF_fluor = 63
#RES ####
colnames(Sig_mtx)[idx_target_fluor]
colnames(Sig_mtx)[idx_AF_fluor]
#the following code applies for all SCCs
desc = data@parameters@data$desc
data = exprs(data)
data = as.data.frame(data)
colnames(data) = desc
colnames(data)
#gate clean data for estimation
#gate singlets
data$gate0 = TRUE
data_backup = data
data = sample_n(data, 20000)
gate1<-PolygonGating(df=data, x_col= "488 FSC-A", y_col= "488 FSC-H", feature_col= "488 FSC-A",
parentgate_col= "gate0", newgate_col= "gate1",canvas_width=800, canvas_height=400)
data <-GateDecider(gate = gate1, df = data)
gate2<-PolygonGating(df=data, x_col= "488 SSC-A", y_col= "488 SSC-H", feature_col= "488 SSC-A",
parentgate_col= "gate1", newgate_col= "gate2",canvas_width=800, canvas_height=400)
data <-GateDecider(gate = gate2, df = data)
gate3<-PolygonGating(df=data, x_col= "488 FSC-A", y_col= "488 SSC-A", feature_col= "488 SSC-A",
parentgate_col= "gate2", newgate_col= "gate3",canvas_width=2000, canvas_height=2000)
data <-GateDecider(gate = gate3, df = data)
data = data_backup
data <-GateDecider(gate = gate1, df = data)
data <-GateDecider(gate = gate2, df = data)
data <-GateDecider(gate = gate3, df = data)
data = data[data$gate3,]
#unmix with target_fluor and AF
data = data[,rownames(Sig_df)]
R = as.matrix(data)
A = Sig_mtx[,c(idx_target_fluor,idx_AF_fluor), drop = FALSE]
A_pinv = ginv(A)
B = R %*% A
colnames(Sig_mtx)[idx_target_fluor]
data = cbind(data,B)
data$gate0 = TRUE
#RES ####
colnames(Sig_mtx)[idx_target_fluor]
colnames(Sig_mtx)[idx_AF_fluor]
#the following code applies for all SCCs
desc = data@parameters@data$desc
data = exprs(data)
#SCC_Cell_CD3_BV510 ####
data = read.FCS(paste0(data_dir,"/SCC_Cell_CD3 Run 1 20241112112836.fcs"))
save_suf = "SCC_Cell_CD3_BV510"
idx_target_fluor = 34
#RES ####
colnames(Sig_mtx)[idx_target_fluor]
colnames(Sig_mtx)[idx_AF_fluor]
#the following code applies for all SCCs
desc = data@parameters@data$desc
data = exprs(data)
data = as.data.frame(data)
colnames(data) = desc
colnames(data)
#gate clean data for estimation
#gate singlets
data$gate0 = TRUE
data_backup = data
data = sample_n(data, 20000)
gate1<-PolygonGating(df=data, x_col= "488 FSC-A", y_col= "488 FSC-H", feature_col= "488 FSC-A",
parentgate_col= "gate0", newgate_col= "gate1",canvas_width=800, canvas_height=400)
data <-GateDecider(gate = gate1, df = data)
gate2<-PolygonGating(df=data, x_col= "488 SSC-A", y_col= "488 SSC-H", feature_col= "488 SSC-A",
parentgate_col= "gate1", newgate_col= "gate2",canvas_width=800, canvas_height=400)
data <-GateDecider(gate = gate2, df = data)
gate3<-PolygonGating(df=data, x_col= "488 FSC-A", y_col= "488 SSC-A", feature_col= "488 SSC-A",
parentgate_col= "gate2", newgate_col= "gate3",canvas_width=2000, canvas_height=2000)
data <-GateDecider(gate = gate3, df = data)
data = data_backup
data <-GateDecider(gate = gate1, df = data)
data <-GateDecider(gate = gate2, df = data)
data <-GateDecider(gate = gate3, df = data)
data = data[data$gate3,]
#unmix with target_fluor and AF
data = data[,rownames(Sig_df)]
R = as.matrix(data)
dim(R)
A = Sig_mtx[,c(idx_target_fluor,idx_AF_fluor), drop = FALSE]
dim(A)
A_pinv = ginv(A)
dim(A_pinv)
B = R %*% A
dim(B)
B = R %*% A_pinv
A%*% A_pinv
A_pinv %*% A
dim(A)
dim(R)
dim(R)
R = t(as.matrix(data))
dim(R)
A = Sig_mtx[,c(idx_target_fluor,idx_AF_fluor), drop = FALSE]
dim(A)
A_pinv = ginv(A)
dim(A_pinv)
B = R %*% A_pinv
B =  A_pinv %*% R
dim(B)
colnames(Sig_mtx)[idx_target_fluor]
data = cbind(data,t(B))
data$gate0 = TRUE
#gate normal samples
data = data[(data[,colnames(Sig_mtx)[idx_target_fluor]] <
quantile(data[,colnames(Sig_mtx)[idx_target_fluor]],0.99)),]
View(B)
t_B = t(B)
rownames(t_B) = c(idx_target_fluor,idx_AF_fluor)
dim(B)
t_B = t(B)
colnames(t_B) = c(idx_target_fluor,idx_AF_fluor)
data = cbind(data,t_B)
data$gate0 = TRUE
#gate normal samples
data = data[(data[,colnames(Sig_mtx)[idx_target_fluor]] <
quantile(data[,colnames(Sig_mtx)[idx_target_fluor]],0.99)),]
View(t_B)
t_B = t(B)
colnames(t_B) = c(colnames(Sig_mtx)[idx_target_fluor],colnames(Sig_mtx)[idx_AF_fluor])
data = cbind(data,t_B)
data$gate0 = TRUE
#gate normal samples
data = data[(data[,colnames(Sig_mtx)[idx_target_fluor]] <
quantile(data[,colnames(Sig_mtx)[idx_target_fluor]],0.99)),]
data = data[(data[,colnames(Sig_mtx)[idx_target_fluor]] >
quantile(data[,colnames(Sig_mtx)[idx_target_fluor]],0.01)),]
data_backup = data
data = sample_n(data, 20000)
# data = data[(data[,colnames(Sig_mtx)[idx_AF_fluor]] < quantile(data[,colnames(Sig_mtx)[idx_AF_fluor]],0.999)),]
gate_normal<-PolygonGating(df=data, x_col= colnames(Sig_mtx)[idx_target_fluor],
y_col= colnames(Sig_mtx)[idx_AF_fluor],
feature_col= colnames(Sig_mtx)[idx_target_fluor],
parentgate_col= "gate0", newgate_col= "gate_normal",canvas_width=800, canvas_height=400)
rownames(Sig_df)
# data = data[(data[,colnames(Sig_mtx)[idx_AF_fluor]] < quantile(data[,colnames(Sig_mtx)[idx_AF_fluor]],0.999)),]
gate_normal<-PolygonGating(df=data, x_col= colnames(Sig_mtx)[idx_target_fluor],
y_col= colnames(Sig_mtx)[idx_AF_fluor],
feature_col= colnames(Sig_mtx)[idx_target_fluor],
parentgate_col= "gate0", newgate_col= "gate_normal",canvas_width=800, canvas_height=400)
data = data_backup
data = GateDecider(gate = gate_normal, df = data)
data = data[data$gate_normal,rownames(Sig_df)]
#calculate residuals
R = as.matrix(data)
A = Sig_mtx[,c(idx_target_fluor), drop = FALSE]
detectors =rownames(Sig_df)
detectors
A
A_pinv = ginv(A)
dim(R)
View(R)
R2 = t(R)
View(R2)
R = t(R)
dim(R)
dim(A)
A_pinv = ginv(A)
B =  A_pinv %*% R
dim(B)
dim(R)
dim(B)
#for following analysis, transform B and R
R = t(R)
B = t(B)
dim(R)
dim(B)
R_explained = B %*% t(A)
dim(R_explained)
#' Estimate slope and intercept matrices from residuals
#'
#' This function performs robust estimation of slope and intercept matrices based on residuals from a signal reconstruction model.
#' It bins the data using either absolute or percentile-based methods, computes robust covariance matrices for each bin,
#' and fits robust linear models to estimate the relationship between covariance values and bin midpoints.
#'
#' @param Res A result object created by \code{\link{CreateRes}}, containing raw signal matrix \code{R}, unmixing matrix \code{A}, and detector information.
#' @param count_thre An integer specifying the minimum number of data points required in a bin to perform covariance estimation.
#' @param bin_num An integer specifying the number of bins to divide the data into. Default is 20.
#' @param bin_method A character string specifying the binning method. Must be either \code{"absolute"} or \code{"percentile"}. Default is \code{"percentile"}.
#' @param z_thre A numeric threshold for removing outliers based on z-scores of the first column of matrix \code{B}. Default is 3.
#' @param ... Additional arguments passed to internal functions (currently unused).
#'
#' @return The updated \code{Res} object with the following fields added:
#' \item{bin_mids}{Midpoints of each bin used for slope estimation.}
#' \item{bin_counts}{Number of data points in each bin.}
#' \item{cov_matrices}{Robust covariance matrices computed for each bin.}
#' \item{interceptMtx}{Matrix of intercepts estimated from robust linear models.}
#' \item{slopMtx}{Matrix of slopes estimated from robust linear models.}
#' \item{par}{A list containing binning parameters used in the estimation.}
#'
#' @examples
#' \dontrun{
#' Res <- CreateRes("F1", R, A)
#' Res <- SlopEstimation(Res, count_thre = 30, bin_num = 20, bin_method = "percentile")
#' }
#' @export
#' @importFrom MASS ginv rlm cov.rob
#' @importFrom stats quantile cov
#' @importFrom progress progress_bar
SlopEstimation = function(Res, count_thre, bin_num = 20, bin_method = "percentile", z_thre = 3, ...){
set.seed(123)
#check if R and A are available
#may skip this
#calculate Residual and B
R = Res$R
A = Res$A #A (detectors x fluors)
detectors = Res$detectors
#unmix
R = t(R) #R (detectors x cells)
A_pinv = ginv(A)
B =  A_pinv %*% R #B (fluors x cells)
#for following analysis, transform B and R
R = t(R)
B = t(B)
R_explained = B %*% t(A)
Residual = R - R_explained
#set default for count_thre
if (missing(count_thre)) {
count_thre = dim(A)[1]
}
#remove outliers based on B
z_scores = scale(B[,1])
mask = abs(z_scores) <= z_thre
B = B[mask, , drop = FALSE]
Residual = Residual[mask, , drop = FALSE]
#calculate bin_size
if(bin_method == "absolute"){
bin_size = (max(B) - min(B)) / bin_num
}else if(bin_method == "percentile"){
bin_size = 1 / bin_num
}else{
stop("Error: bin_method should be 'absolute' or 'percentile'.")
}
#initial cov_matrices and bin_mids
message("calculating cov matrix...")
cov_matrices = array(0, dim = c(dim(A)[1], dim(A)[1], bin_num)) #(51,51,bin_num)
bin_mids = c()
bin_counts = c()
pb <- progress_bar$new(format = "(:spin) [:bar] :percent [Elapsed time: :elapsedfull || Estimated time remaining: :eta]",
total = bin_num,
complete = "=",   # Completion bar character
incomplete = "-", # Incomplete bar character
current = ">",    # Current bar character
clear = FALSE,    # If TRUE, clears the bar when finish
width = 100)
#loop bin and fill cov_matrices and bin_mids
for (i in 1:bin_num) {
pb$tick()
# i = 1
if(bin_method == "absolute"){
bin_min = min(B) + (i - 1) * bin_size  - 1 * bin_size
bin_max = bin_min + bin_size + 1 * bin_size
bin_mid = (bin_min + bin_max) / 2
}else if(bin_method == "percentile"){
bin_min = quantile(B,(i - 1) * bin_size)[[1]]
bin_max = quantile(B,(i) * bin_size)[[1]]
bin_mid = quantile(B,(i - 0.5) * bin_size)[[1]]
}
bin_mask = (B >= bin_min) & (B < bin_max)
bin_points = B[bin_mask]
bin_counts = c(bin_counts, length(bin_points))
if (length(bin_points) > count_thre) {
residuals_in_bin = Residual[bin_mask,]
cov_matrices[ , ,i] = cov.rob(residuals_in_bin)$cov
bin_mids = c(bin_mids, bin_mid)
}else{
bin_mids = c(bin_mids, NA)
}
}
# save bin_mids, bin_counts, cov_matrices,
Res$bin_mids = bin_mids
Res$bin_counts = bin_counts
Res$cov_matrices = cov_matrices
if(any(is.na(bin_mids))){
message(paste0("There are ",sum(is.na(bin_mids)), " bins do not have enough sample for estiamtion."))
}
cov_matrices = cov_matrices[,,(!is.na(bin_mids))]
bin_mids = bin_mids[!is.na(bin_mids)]
#initial interceptMtx and slopMtx
message("calculating slop matrix...")
interceptMtx = array(0, dim = c(dim(A)[1], dim(A)[1]),dimnames = list(detectors,detectors))#(51,51)
slopMtx = interceptMtx #(51,51)
# loop detector pairs to fill interceptMtx and slopMtx
for (i in 1:dim(A)[1]) {
for (j in 1:dim(A)[1]) {
covs = cov_matrices[i,j,]
model_robust = rlm(covs ~ bin_mids)
interceptMtx[i,j] = coef(model_robust)[1]
slopMtx[i,j] = coef(model_robust)[2]
}
}
# save bin_num, count_thre, interceptMtx and slopMtx into Res and return Res
Res$par$bin_num = bin_num
Res$par$bin_method = bin_method
Res$par$count_thre = count_thre
Res$interceptMtx = interceptMtx
Res$slopMtx = slopMtx
return(Res)
}
#SCC_Cell_CD3_BV510 ####
data = read.FCS(paste0(data_dir,"/SCC_Cell_CD3 Run 1 20241112112836.fcs"))
save_suf = "SCC_Cell_CD3_BV510"
idx_target_fluor = 34
idx_AF_fluor = 63
#RES ####
colnames(Sig_mtx)[idx_target_fluor]
colnames(Sig_mtx)[idx_AF_fluor]
#the following code applies for all SCCs
desc = data@parameters@data$desc
data = exprs(data)
data = as.data.frame(data)
colnames(data) = desc
colnames(data)
#gate clean data for estimation
#gate singlets
data$gate0 = TRUE
data_backup = data
data = sample_n(data, 20000)
gate1<-PolygonGating(df=data, x_col= "488 FSC-A", y_col= "488 FSC-H", feature_col= "488 FSC-A",
parentgate_col= "gate0", newgate_col= "gate1",canvas_width=800, canvas_height=400)
data <-GateDecider(gate = gate1, df = data)
gate2<-PolygonGating(df=data, x_col= "488 SSC-A", y_col= "488 SSC-H", feature_col= "488 SSC-A",
parentgate_col= "gate1", newgate_col= "gate2",canvas_width=800, canvas_height=400)
data <-GateDecider(gate = gate2, df = data)
gate3<-PolygonGating(df=data, x_col= "488 FSC-A", y_col= "488 SSC-A", feature_col= "488 SSC-A",
parentgate_col= "gate2", newgate_col= "gate3",canvas_width=2000, canvas_height=2000)
data <-GateDecider(gate = gate3, df = data)
data = data_backup
data <-GateDecider(gate = gate1, df = data)
data <-GateDecider(gate = gate2, df = data)
data <-GateDecider(gate = gate3, df = data)
data = data[data$gate3,]
#unmix with target_fluor and AF
data = data[,rownames(Sig_df)]
R = t(as.matrix(data))
A = Sig_mtx[,c(idx_target_fluor,idx_AF_fluor), drop = FALSE]
A_pinv = ginv(A)
B =  A_pinv %*% R
t_B = t(B)
colnames(t_B) = c(colnames(Sig_mtx)[idx_target_fluor],colnames(Sig_mtx)[idx_AF_fluor])
data = cbind(data,t_B)
data$gate0 = TRUE
#gate normal samples
data = data[(data[,colnames(Sig_mtx)[idx_target_fluor]] <
quantile(data[,colnames(Sig_mtx)[idx_target_fluor]],0.99)),]
data = data[(data[,colnames(Sig_mtx)[idx_target_fluor]] >
quantile(data[,colnames(Sig_mtx)[idx_target_fluor]],0.01)),]
data_backup = data
data = sample_n(data, 20000)
# data = data[(data[,colnames(Sig_mtx)[idx_AF_fluor]] < quantile(data[,colnames(Sig_mtx)[idx_AF_fluor]],0.999)),]
gate_normal<-PolygonGating(df=data, x_col= colnames(Sig_mtx)[idx_target_fluor],
y_col= colnames(Sig_mtx)[idx_AF_fluor],
feature_col= colnames(Sig_mtx)[idx_target_fluor],
parentgate_col= "gate0", newgate_col= "gate_normal",canvas_width=800, canvas_height=400)
data = data_backup
data = GateDecider(gate = gate_normal, df = data)
data = data[data$gate_normal,rownames(Sig_df)]
#calculate residuals
R = as.matrix(data)
A = Sig_mtx[,c(idx_target_fluor), drop = FALSE]
ResObj = CreateRes(id = colnames(Sig_mtx)[idx_target_fluor], R = R, A = A)
ResObj = SlopEstimation(ResObj, bin_num = 50)
devtools::document()
devtools::document()

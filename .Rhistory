grid$z = grid$z + grid_tmp$z
}
#visualize iso band data
# p = PredIsobandPlot(grid = grid,
#                     x_scale = input$x_scale,
#                     y_scale = input$y_scale,
#                     x_cofactor = input$x_cofactor,
#                     y_cofactor = input$y_cofactor,
#                     x_label = input$fluor_selector_x_prediction,
#                     y_label = input$fluor_selector_y_prediction,
#                     x_min = input$x_min_input,
#                     x_max = input$x_max_input,
#                     y_min = input$y_min_input,
#                     y_max = input$y_max_input,
#                     mode = input$prediction_plot_mode,
#                     label_population = population_ids,
#                     intensity_matrix = intensity_cache$matrix)
p = PredIsobandPlotMulti(grid_list = grid_list,
x_scale = input$x_scale,
y_scale = input$y_scale,
x_cofactor = input$x_cofactor,
y_cofactor = input$y_cofactor,
x_label = input$fluor_selector_x_prediction,
y_label = input$fluor_selector_y_prediction,
x_min = input$x_min_input,
x_max = input$x_max_input,
y_min = input$y_min_input,
y_max = input$y_max_input,
mode = input$prediction_plot_mode,
label_population = population_ids,
intensity_matrix = intensity_cache$matrix)
p
})
#Export
observe({
req(fluor_cache$selected)
updateSelectInput(session, "prediction_Nx1_fluor",
choices = fluor_cache$selected,
selected = fluor_cache$selected[1])
})
#downloadHTML
output$downloadHTML <- downloadHandler(
filename = function() {
paste0("UsermMultiple_report-", format(Sys.time(), "%Y-%m-%d_%H_%M_%S"), ".html")
},
content = function(file) {
tempReport <- system.file("report_tmp", "UsermMultiplereport.Rmd", package = "USERM")
# tempReport <- file.path(report_tmp_dir, "UsermMultiplereport.Rmd")
file.copy("UsermMultiplereport.Rmd", tempReport, overwrite = TRUE)
params <- list(Userm = Userm,
detector_selected = detector_cache$selected,
fluor_selected = fluor_cache$selected,
prediction_plot_mode_report = input$prediction_plot_mode_report,
population_ids = population_ids
)
rmarkdown::render(tempReport, output_file = file,
params = params,
output_format = "html_document",
envir = new.env(parent = globalenv()))
}
)
#downloadNxN
output$downloadNxN <- downloadHandler(
filename = function() {
paste0("UsermMultiple_NxN-", format(Sys.time(), "%Y-%m-%d_%H_%M_%S"), ".html")
},
content = function(file) {
tempReport <- system.file("report_tmp", "UsermMultipleNxN.Rmd", package = "USERM")
# tempReport <- file.path(report_tmp_dir, "UsermMultipleNxN.Rmd")
file.copy("UsermMultipleNxN.Rmd", tempReport, overwrite = TRUE)
params <- list(Userm = Userm,
detector_selected = detector_cache$selected,
fluor_selected = fluor_cache$selected,
prediction_plot_mode_report = input$prediction_plot_mode_report,
population_ids = population_ids)
rmarkdown::render(tempReport, output_file = file,
params = params,
output_format = "html_document",
envir = new.env(parent = globalenv()))
}
)
#downloadNx1
output$downloadNx1 <- downloadHandler(
filename = function() {
paste0("UsermMultiple_Nx1-", format(Sys.time(), "%Y-%m-%d_%H_%M_%S"), ".html")
},
content = function(file) {
tempReport <- system.file("report_tmp", "UsermMultipleNx1.Rmd", package = "USERM")
# tempReport <- file.path(report_tmp_dir, "UsermMultipleNx1.Rmd")
file.copy("UsermMultipleNx1.Rmd", tempReport, overwrite = TRUE)
params <- list(Userm = Userm,
detector_selected = detector_cache$selected,
fluor_selected = fluor_cache$selected,
prediction_plot_mode_report = input$prediction_plot_mode_report,
x_fluor = input$prediction_Nx1_fluor,
population_ids = population_ids)
rmarkdown::render(tempReport, output_file = file,
params = params,
output_format = "html_document",
envir = new.env(parent = globalenv()))
}
)
}
# running App
shinyApp(ui = ui, server = server)
}
PredMultipleSpread(Userm = SuprObj,population_ids = c("V1","V2","V3"))
PredIsobandPlotMulti <- function(grid_list,
x_label = "X", y_label = "Y",
x_scale = "Linear", y_scale = "Linear",
x_cofactor = 5, y_cofactor = 5,
x_min = NULL, x_max = NULL,
y_min = NULL, y_max = NULL,
mode = "Pseudo-color",
legend_show = TRUE,
label_population = NA,
intensity_matrix = NA) {
library(ggplot2)
library(scales)
library(dplyr)
# Custom transformation functions
asinh_trans_cofactor <- function(cofactor = 5) {
trans_new(
name = paste0("asinh_", cofactor),
transform = function(x) asinh(x / cofactor),
inverse = function(x) cofactor * sinh(x)
)
}
signed_log10_trans <- function() {
trans_new(
name = "signed_log10",
transform = function(x) sign(x) * log10(abs(x) + 1),
inverse = function(x) sign(x) * (10^abs(x) - 1)
)
}
# Combine all grids and add model name
combined_grid <- bind_rows(
lapply(names(grid_list), function(name) {
df <- grid_list[[name]]
df$model <- name
return(df)
})
)
# Initialize ggplot
p <- ggplot(combined_grid, aes(x = x, y = y, z = z))
# Add plot layers
if (mode == "Pseudo-color") {
p <- p + geom_contour_filled(aes(fill = model), alpha = 0.1)
} else if (mode == "Contour line") {
p <- p + geom_contour(aes(color = model))
}
# Axis labels
p <- p + labs(title = "Overlay of Multiple Prediction Grids",
x = x_label, y = y_label)
# Axis scaling
if (!is.null(x_min) && !is.null(x_max)) {
if (x_scale == "Linear") {
p <- p + xlim(x_min, x_max)
} else if (x_scale == "Log10") {
p <- p + scale_x_continuous(trans = signed_log10_trans(), limits = c(x_min, x_max))
} else if (x_scale == "Arcsinh") {
p <- p + scale_x_continuous(trans = asinh_trans_cofactor(x_cofactor), limits = c(x_min, x_max))
}
}
if (!is.null(y_min) && !is.null(y_max)) {
if (y_scale == "Linear") {
p <- p + ylim(y_min, y_max)
} else if (y_scale == "Log10") {
p <- p + scale_y_continuous(trans = signed_log10_trans(), limits = c(y_min, y_max))
} else if (y_scale == "Arcsinh") {
p <- p + scale_y_continuous(trans = asinh_trans_cofactor(y_cofactor), limits = c(y_min, y_max))
}
}
# Add population label
if (!is.na(label_population[1])) {
label_df <- intensity_matrix[c(x_label, y_label), label_population]
rownames(label_df) <- c("x", "y")
label_df <- as.data.frame(t(label_df))
label_df$population <- rownames(label_df)
label_df$z <- 0
p <- p + geom_text(data = label_df, aes(x = x, y = y, label = population), vjust = -0.5)
}
# Theme and legend
p <- p + theme_light()
if (!legend_show) {
p <- p + theme(legend.position = "none")
}
return(p)
}
PredMultipleSpread(Userm = SuprObj,population_ids = c("V1","V2","V3"))
PredOneSpread(Userm = SuprObj,population_id = c("V1"))
devtools::document()
devtools::document()
# library(rmarkdown)
# library(patchwork)
#
devtools::install_github("xiangmingcai/USERM")
# library(rmarkdown)
# library(patchwork)
#
# devtools::install_github("xiangmingcai/USERM")
library(USERM)
data_dir = "E:/ResidualModel/RscriptSUPR/data"
report_tmp_dir = "E:/ResidualModel/RscriptSUPR/report_tmp"
tmp_dir = "E:/ResidualModel/RscriptSUPR/tmp"
Sig_info = querySig()
Sig_info$id[c(32:38,41:42,44,46:48,50:54,58:62,8,9,12,14,18,24,25,26,63)]
Sig_mtx  = getSigMtx(ids = c(Sig_info$id[c(32:38,41:42,44,46:48,50:54,58:62,8,9,12,14,18,24,25,26,63)]))
SuprObj = CreateUserm(A = Sig_mtx)
#add ResObj into SuprObj
for (save_suf in colnames(Sig_mtx)) {
ResObj = getRes(id = save_suf)
SuprObj = AddRes2Userm(Res = ResObj, Userm = SuprObj)
}
SuprObj[["Scale_df"]][["min"]] = -100
SuprObj[["Scale_df"]][["max"]] = 1000
SuprObj[["Scale_df"]][["scale"]] = "Linear"
SuprObj[["Scale_df"]][["cofactor"]] = 10
SuprObj$Intensity_mtx[,2] = 100*c(1:length(SuprObj$fluors))
SuprObj$Intensity_mtx[,3] = 200*c(1:length(SuprObj$fluors))
colnames(SuprObj$Intensity_mtx)
PredMultipleSpread(Userm = SuprObj,population_ids = c("V1","V2","V3"))
devtools::document()
# library(rmarkdown)
# library(patchwork)
#
# devtools::install_github("xiangmingcai/USERM")
library(USERM)
data_dir = "E:/ResidualModel/RscriptSUPR/data"
report_tmp_dir = "E:/ResidualModel/RscriptSUPR/report_tmp"
tmp_dir = "E:/ResidualModel/RscriptSUPR/tmp"
Sig_info = querySig()
Sig_mtx  = getSigMtx(ids = c(Sig_info$id[c(32:38,41:42,44,46:48,50:54,58:62,8,9,12,14,18,24,25,26,63)]))
SuprObj = CreateUserm(A = Sig_mtx)
#add ResObj into SuprObj
for (save_suf in colnames(Sig_mtx)) {
ResObj = getRes(id = save_suf)
SuprObj = AddRes2Userm(Res = ResObj, Userm = SuprObj)
}
SuprObj[["Scale_df"]][["min"]] = -100
SuprObj[["Scale_df"]][["max"]] = 1000
SuprObj[["Scale_df"]][["scale"]] = "Linear"
SuprObj[["Scale_df"]][["cofactor"]] = 10
SuprObj$Intensity_mtx[,2] = 100*c(1:length(SuprObj$fluors))
SuprObj$Intensity_mtx[,3] = 200*c(1:length(SuprObj$fluors))
PredOneSpread(Userm = SuprObj,population_id = c("V1"))
View(ResObj)
ResObj$slopMtx
Res = ResObj
if (is.null(Res$slopMtx) || !is.matrix(Res$slopMtx)) {
stop("Res$slopMtx is missing or not a matrix.")
}
heatmap(Res$slopMtx, main = "slopMtx", col = heat.colors(256))
mat <- Res$slopMtx
zlim <- range(mat, na.rm = TRUE)
zlim
# Plot heatmap without clustering
image(t(mat[nrow(mat):1, ]), col = col, zlim = zlim,
axes = FALSE, main = "Heatmap of slopMtx (no clustering)")
col = heat.colors(100)
# Plot heatmap without clustering
image(t(mat[nrow(mat):1, ]), col = col, zlim = zlim,
axes = FALSE, main = "Heatmap of slopMtx (no clustering)")
#' @param col A vector of colors to use for the heatmap. Default is \code{heat.colors(100)}.
#'
#' @return A heatmap plot of \code{Res$slopMtx}. If \code{slopMtx} is not found, the function stops with an error.
#'
#' @examples
#' \dontrun{
#' Res <- list(slopMtx = matrix(runif(100), nrow = 10))
#' checkRes_slopMtx(Res, zlim = c(0, 1))
#' }
#' @export
checkRes_slopMtx <- function(Res, min = -1, mid = 0, max = 1, mincolor = "blue", midcolor = "white", maxcolor = "red") {
if (is.null(Res$slopMtx) || !is.matrix(Res$slopMtx)) {
stop("Res$slopMtx is missing or not a matrix.")
}
col_fun = colorRamp2(c(min, mid, max), c(mincolor, midcolor, maxcolor))
p = Heatmap(Res$slopMtx,col = col_fun, cluster_rows = FALSE,cluster_columns = FALSE,
cell_fun = function(j, i, x, y, width, height, fill) {
grid.text(sprintf("%.1f", ResObj$slopMtx[i, j]), x, y, gp = gpar(fontsize = 6))
},column_title = colnames(Sig_mtx)[idx_target_fluor],name = "beta")
return(p)
}
checkRes_slopMtx(Res = ResObj)
library(ComplexHeatmap)
library(circlize)
checkRes_slopMtx(Res = ResObj)
#' @param col A vector of colors to use for the heatmap. Default is \code{heat.colors(100)}.
#'
#' @return A heatmap plot of \code{Res$slopMtx}. If \code{slopMtx} is not found, the function stops with an error.
#'
#' @examples
#' \dontrun{
#' Res <- list(slopMtx = matrix(runif(100), nrow = 10))
#' checkRes_slopMtx(Res, zlim = c(0, 1))
#' }
#' @export
checkRes_slopMtx <- function(Res, min = -1, mid = 0, max = 1, mincolor = "blue", midcolor = "white", maxcolor = "red") {
if (is.null(Res$slopMtx) || !is.matrix(Res$slopMtx)) {
stop("Res$slopMtx is missing or not a matrix.")
}
col_fun = colorRamp2(c(min, mid, max), c(mincolor, midcolor, maxcolor))
p = Heatmap(Res$slopMtx,col = col_fun, cluster_rows = FALSE,cluster_columns = FALSE,
cell_fun = function(j, i, x, y, width, height, fill) {
grid.text(sprintf("%.1f", Res$slopMtx[i, j]), x, y, gp = gpar(fontsize = 6))
},column_title = paste0("slopMtx of ", Res$id),name = "beta")
return(p)
}
checkRes_slopMtx(Res = ResObj)
checkRes_interceptMtx <- function(Res, min = -10, mid = 0, max = 10, mincolor = "blue", midcolor = "white", maxcolor = "red") {
if (is.null(Res$interceptMtx) || !is.matrix(Res$interceptMtx)) {
stop("Res$interceptMtx is missing or not a matrix.")
}
col_fun = colorRamp2(c(min, mid, max), c(mincolor, midcolor, maxcolor))
p = Heatmap(Res$interceptMtx,col = col_fun, cluster_rows = FALSE,cluster_columns = FALSE,
cell_fun = function(j, i, x, y, width, height, fill) {
grid.text(sprintf("%.1f", Res$interceptMtx[i, j]), x, y, gp = gpar(fontsize = 6))
},column_title = paste0("interceptMtx of ", Res$id),name = "intercept")
return(p)
}
checkRes_interceptMtx(Res = ResObj)
checkRes_covMtx <- function(Res, bin = 1, min = -1, mid = 0, max = 1, mincolor = "blue", midcolor = "white", maxcolor = "red") {
if (is.null(Res$cov_matrices[,,bin]) || !is.matrix(Res$cov_matrices[,,bin])) {
stop("Res$cov_matrices[,,bin] is missing or not a matrix.")
}
col_fun = colorRamp2(c(min, mid, max), c(mincolor, midcolor, maxcolor))
p = Heatmap(Res$cov_matrices[,,bin],col = col_fun, cluster_rows = FALSE,cluster_columns = FALSE,
cell_fun = function(j, i, x, y, width, height, fill) {
grid.text(sprintf("%.1f", Res$cov_matrices[,,bin][i, j]), x, y, gp = gpar(fontsize = 6))
},column_title = paste0("cov_matrix of ", Res$id, "at bin_mid = ",Res$bin_mids[bin]),name = "cov")
return(p)
}
checkRes_covMtx(Res,bin=1)
checkRes_covMtx <- function(Res, bin = 1, min = -1, mid = 0, max = 1, mincolor = "blue", midcolor = "white", maxcolor = "red") {
if (is.null(Res$cov_matrices[,,bin]) || !is.matrix(Res$cov_matrices[,,bin])) {
stop("Res$cov_matrices[,,bin] is missing or not a matrix.")
}
mat = Res$cov_matrices[,,bin]
rownames(mat) = Res$detectors
colnames(mat) = Res$detectors
col_fun = colorRamp2(c(min, mid, max), c(mincolor, midcolor, maxcolor))
p = Heatmap(mat,col = col_fun, cluster_rows = FALSE,cluster_columns = FALSE,
cell_fun = function(j, i, x, y, width, height, fill) {
grid.text(sprintf("%.1f", mat[i, j]), x, y, gp = gpar(fontsize = 6))
},column_title = paste0("cov_matrix of ", Res$id, "at bin_mid = ",Res$bin_mids[bin]),name = "cov")
return(p)
}
checkRes_covMtx(Res,bin=1)
checkRes_covMtx <- function(Res, bin = 1, min = -1, mid = 0, max = 1, mincolor = "blue", midcolor = "white", maxcolor = "red") {
if (is.null(Res$cov_matrices[,,bin]) || !is.matrix(Res$cov_matrices[,,bin])) {
stop("Res$cov_matrices[,,bin] is missing or not a matrix.")
}
mat = Res$cov_matrices[,,bin]
rownames(mat) = Res$detectors
colnames(mat) = Res$detectors
col_fun = colorRamp2(c(min, mid, max), c(mincolor, midcolor, maxcolor))
p = Heatmap(mat,col = col_fun, cluster_rows = FALSE,cluster_columns = FALSE,
cell_fun = function(j, i, x, y, width, height, fill) {
grid.text(sprintf("%.1f", mat[i, j]), x, y, gp = gpar(fontsize = 6))
},column_title = paste0("cov_matrix of ", Res$id, "at bin_mid = ",round(Res$bin_mids[bin],digits = 2)),name = "cov")
return(p)
}
checkRes_covMtx(Res,bin=1)
checkRes_covMtx <- function(Res, bin = 1, min = -1, mid = 0, max = 1, mincolor = "blue", midcolor = "white", maxcolor = "red") {
if (is.null(Res$cov_matrices[,,bin]) || !is.matrix(Res$cov_matrices[,,bin])) {
stop("Res$cov_matrices[,,bin] is missing or not a matrix.")
}
mat = Res$cov_matrices[,,bin]
rownames(mat) = Res$detectors
colnames(mat) = Res$detectors
col_fun = colorRamp2(c(min, mid, max), c(mincolor, midcolor, maxcolor))
p = Heatmap(mat,col = col_fun, cluster_rows = FALSE,cluster_columns = FALSE,
cell_fun = function(j, i, x, y, width, height, fill) {
grid.text(sprintf("%.1f", mat[i, j]), x, y, gp = gpar(fontsize = 6))
},column_title = paste0("cov_matrix of ", Res$id, " at bin_mid = ",round(Res$bin_mids[bin],digits = 2)),name = "cov")
return(p)
}
checkRes_covMtx(Res,bin=2)
checkRes_covMtx(Res,bin=3)
ResObj$bin_mids
ResObj$detectors
detector2 = ResObj$detectors[2]
detector1 = ResObj$detectors[1]
detectors = Res$detectors
x = Res$bin_mids
detectors = Res$detectors
detector1 == detectors
y = Res$cov_matrices[detector1 == detectors,detector2 == detectors,]
y
detector2 == detectors
checkRes_covScatter <- function(Res, detector1, detector2) {
x <- Res$bin_mids
detectors <- Res$detectors
# Find the index of the specified detectors
idx1 <- which(detectors == detector1)
idx2 <- which(detectors == detector2)
if (length(idx1) == 0 || length(idx2) == 0) {
stop("Specified detectors not found in Res$detectors.")
}
y <- Res$cov_matrices[idx1, idx2, ]
slope <- Res$slopMtx[idx1, idx2]
intercept <- Res$interceptMtx[idx1, idx2]
df <- data.frame(x = x, y = y)
p <- ggplot(df, aes(x = x, y = y)) +
geom_point(color = "black") +
geom_abline(slope = slope, intercept = intercept, color = "red", linetype = "dashed") +
labs(
title = paste("Covariance between", detector1, "and", detector2),
x = "Bin Midpoints",
y = "Covariance"
) +
theme_minimal()
return(p)
}
checkRes_covScatter(Res = ResObj,
detector1 = ResObj$detectors[1],
detector2 = ResObj$detectors[2])
library(ggplot2)
checkRes_covScatter <- function(Res, detector1, detector2) {
x <- Res$bin_mids
detectors <- Res$detectors
# Find the index of the specified detectors
idx1 <- which(detectors == detector1)
idx2 <- which(detectors == detector2)
if (length(idx1) == 0 || length(idx2) == 0) {
stop("Specified detectors not found in Res$detectors.")
}
y <- Res$cov_matrices[idx1, idx2, ]
slope <- Res$slopMtx[idx1, idx2]
intercept <- Res$interceptMtx[idx1, idx2]
df <- data.frame(x = x, y = y)
p <- ggplot(df, aes(x = x, y = y)) +
geom_point(color = "black") +
geom_abline(slope = slope, intercept = intercept, color = "red", linetype = "dashed") +
labs(
title = paste("Covariance between", detector1, "and", detector2),
x = "Bin Midpoints",
y = "Covariance"
) +
theme_minimal()
return(p)
}
checkRes_covScatter(Res = ResObj,
detector1 = ResObj$detectors[1],
detector2 = ResObj$detectors[2])
checkRes_covScatter <- function(Res, detector1, detector2) {
x <- Res$bin_mids
detectors <- Res$detectors
# Find the index of the specified detectors
idx1 <- which(detectors == detector1)
idx2 <- which(detectors == detector2)
if (length(idx1) == 0 || length(idx2) == 0) {
stop("Specified detectors not found in Res$detectors.")
}
y <- Res$cov_matrices[idx1, idx2, ]
slope <- Res$slopMtx[idx1, idx2]
intercept <- Res$interceptMtx[idx1, idx2]
df <- data.frame(x = x, y = y)
title_text <- sprintf(
"Covariance between %s and %s (slope = %.3f, intercept = %.3f)",
detector1, detector2, slope, intercept
)
p <- ggplot(df, aes(x = x, y = y)) +
geom_point(color = "black") +
geom_abline(slope = slope, intercept = intercept, color = "red", linetype = "dashed") +
labs(
title = title_text,
x = "Bin Midpoints",
y = "Covariance"
) +
theme_minimal()
return(p)
}
checkRes_covScatter(Res = ResObj,
detector1 = ResObj$detectors[1],
detector2 = ResObj$detectors[2])
checkRes_covScatter <- function(Res, detector1, detector2) {
x <- Res$bin_mids
detectors <- Res$detectors
# Find the index of the specified detectors
idx1 <- which(detectors == detector1)
idx2 <- which(detectors == detector2)
if (length(idx1) == 0 || length(idx2) == 0) {
stop("Specified detectors not found in Res$detectors.")
}
y <- Res$cov_matrices[idx1, idx2, ]
slope <- Res$slopMtx[idx1, idx2]
intercept <- Res$interceptMtx[idx1, idx2]
df <- data.frame(x = x, y = y)
title_text <- sprintf(
"Covariance between %s and %s (slope = %.3f, intercept = %.3f)",
detector1, detector2, slope, intercept
)
p <- ggplot(df, aes(x = x, y = y)) +
geom_point(color = "black") +
geom_abline(slope = slope, intercept = intercept, color = "red", linetype = "dashed") +
labs(
title = title_text,
x = "Bin Midpoints",
y = "Covariance"
) +
theme_light()
return(p)
}
checkRes_covScatter(Res = ResObj,
detector1 = ResObj$detectors[1],
detector2 = ResObj$detectors[2])
is.null(Res$cov_matrices)
Res$cov_matrices
is.matrix(Res$cov_matrices)
devtools::document()

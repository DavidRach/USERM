quantile(data[,colnames(Sig_mtx)[idx_target_fluor]],0.01)),]
data_backup = data
data = sample_n(data, 20000)
# data = data[(data[,colnames(Sig_mtx)[idx_AF_fluor]] < quantile(data[,colnames(Sig_mtx)[idx_AF_fluor]],0.999)),]
gate_normal<-PolygonGating(df=data, x_col= colnames(Sig_mtx)[idx_target_fluor],
y_col= colnames(Sig_mtx)[idx_AF_fluor],
feature_col= colnames(Sig_mtx)[idx_target_fluor],
parentgate_col= "gate0", newgate_col= "gate_normal",canvas_width=800, canvas_height=400)
rownames(Sig_df)
# data = data[(data[,colnames(Sig_mtx)[idx_AF_fluor]] < quantile(data[,colnames(Sig_mtx)[idx_AF_fluor]],0.999)),]
gate_normal<-PolygonGating(df=data, x_col= colnames(Sig_mtx)[idx_target_fluor],
y_col= colnames(Sig_mtx)[idx_AF_fluor],
feature_col= colnames(Sig_mtx)[idx_target_fluor],
parentgate_col= "gate0", newgate_col= "gate_normal",canvas_width=800, canvas_height=400)
data = data_backup
data = GateDecider(gate = gate_normal, df = data)
data = data[data$gate_normal,rownames(Sig_df)]
#calculate residuals
R = as.matrix(data)
A = Sig_mtx[,c(idx_target_fluor), drop = FALSE]
detectors =rownames(Sig_df)
detectors
A
A_pinv = ginv(A)
dim(R)
View(R)
R2 = t(R)
View(R2)
R = t(R)
dim(R)
dim(A)
A_pinv = ginv(A)
B =  A_pinv %*% R
dim(B)
dim(R)
dim(B)
#for following analysis, transform B and R
R = t(R)
B = t(B)
dim(R)
dim(B)
R_explained = B %*% t(A)
dim(R_explained)
#' Estimate slope and intercept matrices from residuals
#'
#' This function performs robust estimation of slope and intercept matrices based on residuals from a signal reconstruction model.
#' It bins the data using either absolute or percentile-based methods, computes robust covariance matrices for each bin,
#' and fits robust linear models to estimate the relationship between covariance values and bin midpoints.
#'
#' @param Res A result object created by \code{\link{CreateRes}}, containing raw signal matrix \code{R}, unmixing matrix \code{A}, and detector information.
#' @param count_thre An integer specifying the minimum number of data points required in a bin to perform covariance estimation.
#' @param bin_num An integer specifying the number of bins to divide the data into. Default is 20.
#' @param bin_method A character string specifying the binning method. Must be either \code{"absolute"} or \code{"percentile"}. Default is \code{"percentile"}.
#' @param z_thre A numeric threshold for removing outliers based on z-scores of the first column of matrix \code{B}. Default is 3.
#' @param ... Additional arguments passed to internal functions (currently unused).
#'
#' @return The updated \code{Res} object with the following fields added:
#' \item{bin_mids}{Midpoints of each bin used for slope estimation.}
#' \item{bin_counts}{Number of data points in each bin.}
#' \item{cov_matrices}{Robust covariance matrices computed for each bin.}
#' \item{interceptMtx}{Matrix of intercepts estimated from robust linear models.}
#' \item{slopMtx}{Matrix of slopes estimated from robust linear models.}
#' \item{par}{A list containing binning parameters used in the estimation.}
#'
#' @examples
#' \dontrun{
#' Res <- CreateRes("F1", R, A)
#' Res <- SlopEstimation(Res, count_thre = 30, bin_num = 20, bin_method = "percentile")
#' }
#' @export
#' @importFrom MASS ginv rlm cov.rob
#' @importFrom stats quantile cov
#' @importFrom progress progress_bar
SlopEstimation = function(Res, count_thre, bin_num = 20, bin_method = "percentile", z_thre = 3, ...){
set.seed(123)
#check if R and A are available
#may skip this
#calculate Residual and B
R = Res$R
A = Res$A #A (detectors x fluors)
detectors = Res$detectors
#unmix
R = t(R) #R (detectors x cells)
A_pinv = ginv(A)
B =  A_pinv %*% R #B (fluors x cells)
#for following analysis, transform B and R
R = t(R)
B = t(B)
R_explained = B %*% t(A)
Residual = R - R_explained
#set default for count_thre
if (missing(count_thre)) {
count_thre = dim(A)[1]
}
#remove outliers based on B
z_scores = scale(B[,1])
mask = abs(z_scores) <= z_thre
B = B[mask, , drop = FALSE]
Residual = Residual[mask, , drop = FALSE]
#calculate bin_size
if(bin_method == "absolute"){
bin_size = (max(B) - min(B)) / bin_num
}else if(bin_method == "percentile"){
bin_size = 1 / bin_num
}else{
stop("Error: bin_method should be 'absolute' or 'percentile'.")
}
#initial cov_matrices and bin_mids
message("calculating cov matrix...")
cov_matrices = array(0, dim = c(dim(A)[1], dim(A)[1], bin_num)) #(51,51,bin_num)
bin_mids = c()
bin_counts = c()
pb <- progress_bar$new(format = "(:spin) [:bar] :percent [Elapsed time: :elapsedfull || Estimated time remaining: :eta]",
total = bin_num,
complete = "=",   # Completion bar character
incomplete = "-", # Incomplete bar character
current = ">",    # Current bar character
clear = FALSE,    # If TRUE, clears the bar when finish
width = 100)
#loop bin and fill cov_matrices and bin_mids
for (i in 1:bin_num) {
pb$tick()
# i = 1
if(bin_method == "absolute"){
bin_min = min(B) + (i - 1) * bin_size  - 1 * bin_size
bin_max = bin_min + bin_size + 1 * bin_size
bin_mid = (bin_min + bin_max) / 2
}else if(bin_method == "percentile"){
bin_min = quantile(B,(i - 1) * bin_size)[[1]]
bin_max = quantile(B,(i) * bin_size)[[1]]
bin_mid = quantile(B,(i - 0.5) * bin_size)[[1]]
}
bin_mask = (B >= bin_min) & (B < bin_max)
bin_points = B[bin_mask]
bin_counts = c(bin_counts, length(bin_points))
if (length(bin_points) > count_thre) {
residuals_in_bin = Residual[bin_mask,]
cov_matrices[ , ,i] = cov.rob(residuals_in_bin)$cov
bin_mids = c(bin_mids, bin_mid)
}else{
bin_mids = c(bin_mids, NA)
}
}
# save bin_mids, bin_counts, cov_matrices,
Res$bin_mids = bin_mids
Res$bin_counts = bin_counts
Res$cov_matrices = cov_matrices
if(any(is.na(bin_mids))){
message(paste0("There are ",sum(is.na(bin_mids)), " bins do not have enough sample for estiamtion."))
}
cov_matrices = cov_matrices[,,(!is.na(bin_mids))]
bin_mids = bin_mids[!is.na(bin_mids)]
#initial interceptMtx and slopMtx
message("calculating slop matrix...")
interceptMtx = array(0, dim = c(dim(A)[1], dim(A)[1]),dimnames = list(detectors,detectors))#(51,51)
slopMtx = interceptMtx #(51,51)
# loop detector pairs to fill interceptMtx and slopMtx
for (i in 1:dim(A)[1]) {
for (j in 1:dim(A)[1]) {
covs = cov_matrices[i,j,]
model_robust = rlm(covs ~ bin_mids)
interceptMtx[i,j] = coef(model_robust)[1]
slopMtx[i,j] = coef(model_robust)[2]
}
}
# save bin_num, count_thre, interceptMtx and slopMtx into Res and return Res
Res$par$bin_num = bin_num
Res$par$bin_method = bin_method
Res$par$count_thre = count_thre
Res$interceptMtx = interceptMtx
Res$slopMtx = slopMtx
return(Res)
}
#SCC_Cell_CD3_BV510 ####
data = read.FCS(paste0(data_dir,"/SCC_Cell_CD3 Run 1 20241112112836.fcs"))
save_suf = "SCC_Cell_CD3_BV510"
idx_target_fluor = 34
idx_AF_fluor = 63
#RES ####
colnames(Sig_mtx)[idx_target_fluor]
colnames(Sig_mtx)[idx_AF_fluor]
#the following code applies for all SCCs
desc = data@parameters@data$desc
data = exprs(data)
data = as.data.frame(data)
colnames(data) = desc
colnames(data)
#gate clean data for estimation
#gate singlets
data$gate0 = TRUE
data_backup = data
data = sample_n(data, 20000)
gate1<-PolygonGating(df=data, x_col= "488 FSC-A", y_col= "488 FSC-H", feature_col= "488 FSC-A",
parentgate_col= "gate0", newgate_col= "gate1",canvas_width=800, canvas_height=400)
data <-GateDecider(gate = gate1, df = data)
gate2<-PolygonGating(df=data, x_col= "488 SSC-A", y_col= "488 SSC-H", feature_col= "488 SSC-A",
parentgate_col= "gate1", newgate_col= "gate2",canvas_width=800, canvas_height=400)
data <-GateDecider(gate = gate2, df = data)
gate3<-PolygonGating(df=data, x_col= "488 FSC-A", y_col= "488 SSC-A", feature_col= "488 SSC-A",
parentgate_col= "gate2", newgate_col= "gate3",canvas_width=2000, canvas_height=2000)
data <-GateDecider(gate = gate3, df = data)
data = data_backup
data <-GateDecider(gate = gate1, df = data)
data <-GateDecider(gate = gate2, df = data)
data <-GateDecider(gate = gate3, df = data)
data = data[data$gate3,]
#unmix with target_fluor and AF
data = data[,rownames(Sig_df)]
R = t(as.matrix(data))
A = Sig_mtx[,c(idx_target_fluor,idx_AF_fluor), drop = FALSE]
A_pinv = ginv(A)
B =  A_pinv %*% R
t_B = t(B)
colnames(t_B) = c(colnames(Sig_mtx)[idx_target_fluor],colnames(Sig_mtx)[idx_AF_fluor])
data = cbind(data,t_B)
data$gate0 = TRUE
#gate normal samples
data = data[(data[,colnames(Sig_mtx)[idx_target_fluor]] <
quantile(data[,colnames(Sig_mtx)[idx_target_fluor]],0.99)),]
data = data[(data[,colnames(Sig_mtx)[idx_target_fluor]] >
quantile(data[,colnames(Sig_mtx)[idx_target_fluor]],0.01)),]
data_backup = data
data = sample_n(data, 20000)
# data = data[(data[,colnames(Sig_mtx)[idx_AF_fluor]] < quantile(data[,colnames(Sig_mtx)[idx_AF_fluor]],0.999)),]
gate_normal<-PolygonGating(df=data, x_col= colnames(Sig_mtx)[idx_target_fluor],
y_col= colnames(Sig_mtx)[idx_AF_fluor],
feature_col= colnames(Sig_mtx)[idx_target_fluor],
parentgate_col= "gate0", newgate_col= "gate_normal",canvas_width=800, canvas_height=400)
data = data_backup
data = GateDecider(gate = gate_normal, df = data)
data = data[data$gate_normal,rownames(Sig_df)]
#calculate residuals
R = as.matrix(data)
A = Sig_mtx[,c(idx_target_fluor), drop = FALSE]
ResObj = CreateRes(id = colnames(Sig_mtx)[idx_target_fluor], R = R, A = A)
ResObj = SlopEstimation(ResObj, bin_num = 50)
devtools::document()
devtools::document()
devtools::install_github("xiangmingcai/USERM")
# library(rmarkdown)
# library(patchwork)
#
# devtools::install_github("xiangmingcai/USERM")
library(USERM)
# library(rmarkdown)
# library(patchwork)
#
# devtools::install_github("xiangmingcai/USERM")
library(USERM)
library(ComplexHeatmap)
library(circlize)
# #read in SCC fcs
library(flowCore)
library(MASS)
library(GateData)
library(ggplot2)
# library(reshape2)
# library(progress)
# library(shiny)
# library(DT)
library(dplyr)
data_dir = "E:/ResidualModel/RscriptSUPR/data"
report_tmp_dir = "E:/ResidualModel/RscriptSUPR/report_tmp"
tmp_dir = "E:/ResidualModel/RscriptSUPR/tmp"
Sig_list = readRDS(paste0(tmp_dir,"/Sig_list.rds"))
Sig_df = SigList2df(SigList= Sig_list[1:63],SigName = "id")
Sig_mtx = as.matrix(Sig_df)
colnames(Sig_mtx)
#SCC_Cell_CD3_BV510 ####
data = read.FCS(paste0(data_dir,"/SCC_Cell_CD3 Run 1 20241112112836.fcs"))
save_suf = "SCC_Cell_CD3_BV510"
idx_target_fluor = 34
idx_AF_fluor = 63
#RES ####
colnames(Sig_mtx)[idx_target_fluor]
colnames(Sig_mtx)[idx_AF_fluor]
#the following code applies for all SCCs
desc = data@parameters@data$desc
data = exprs(data)
data = as.data.frame(data)
colnames(data) = desc
colnames(data)
#gate clean data for estimation
#gate singlets
data$gate0 = TRUE
data_backup = data
data = sample_n(data, 20000)
gate1<-PolygonGating(df=data, x_col= "488 FSC-A", y_col= "488 FSC-H", feature_col= "488 FSC-A",
parentgate_col= "gate0", newgate_col= "gate1",canvas_width=800, canvas_height=400)
data <-GateDecider(gate = gate1, df = data)
gate2<-PolygonGating(df=data, x_col= "488 SSC-A", y_col= "488 SSC-H", feature_col= "488 SSC-A",
parentgate_col= "gate1", newgate_col= "gate2",canvas_width=800, canvas_height=400)
data <-GateDecider(gate = gate2, df = data)
gate3<-PolygonGating(df=data, x_col= "488 FSC-A", y_col= "488 SSC-A", feature_col= "488 SSC-A",
parentgate_col= "gate2", newgate_col= "gate3",canvas_width=2000, canvas_height=2000)
data <-GateDecider(gate = gate3, df = data)
data = data_backup
data <-GateDecider(gate = gate1, df = data)
data <-GateDecider(gate = gate2, df = data)
data <-GateDecider(gate = gate3, df = data)
data = data[data$gate3,]
#unmix with target_fluor and AF
data = data[,rownames(Sig_df)]
R = t(as.matrix(data))
A = Sig_mtx[,c(idx_target_fluor,idx_AF_fluor), drop = FALSE]
A_pinv = ginv(A)
B =  A_pinv %*% R
t_B = t(B)
colnames(t_B) = c(colnames(Sig_mtx)[idx_target_fluor],colnames(Sig_mtx)[idx_AF_fluor])
data = cbind(data,t_B)
data$gate0 = TRUE
#gate normal samples
data = data[(data[,colnames(Sig_mtx)[idx_target_fluor]] <
quantile(data[,colnames(Sig_mtx)[idx_target_fluor]],0.99)),]
data = data[(data[,colnames(Sig_mtx)[idx_target_fluor]] >
quantile(data[,colnames(Sig_mtx)[idx_target_fluor]],0.01)),]
data_backup = data
data = sample_n(data, 20000)
# data = data[(data[,colnames(Sig_mtx)[idx_AF_fluor]] < quantile(data[,colnames(Sig_mtx)[idx_AF_fluor]],0.999)),]
gate_normal<-PolygonGating(df=data, x_col= colnames(Sig_mtx)[idx_target_fluor],
y_col= colnames(Sig_mtx)[idx_AF_fluor],
feature_col= colnames(Sig_mtx)[idx_target_fluor],
parentgate_col= "gate0", newgate_col= "gate_normal",canvas_width=800, canvas_height=400)
data = data_backup
data = GateDecider(gate = gate_normal, df = data)
data = data[data$gate_normal,rownames(Sig_df)]
#calculate residuals
R = as.matrix(data)
A = Sig_mtx[,c(idx_target_fluor), drop = FALSE]
ResObj = CreateRes(id = colnames(Sig_mtx)[idx_target_fluor], R = R, A = A)
bin_num = 30
Res = ResObj
set.seed(123)
#calculate Residual and B
R = Res$R
A = Res$A #A (detectors x fluors)
detectors = Res$detectors
#unmix
R = t(R) #R (detectors x cells)
A_pinv = ginv(A)
B =  A_pinv %*% R #B (fluors x cells)
#for following analysis, transform B and R
R = t(R)
B = t(B)
R_explained = B %*% t(A)
Residual = R - R_explained
count_thre = dim(A)[1]
count_thre
#remove outliers based on B
z_scores = scale(B[,1])
mask = abs(z_scores) <= z_thre
# table(mask)
B = B[mask, , drop = FALSE]
Residual = Residual[mask, , drop = FALSE]
bin_method = "percentile"
z_thre = 3
#remove outliers based on B
z_scores = scale(B[,1])
mask = abs(z_scores) <= z_thre
# table(mask)
B = B[mask, , drop = FALSE]
Residual = Residual[mask, , drop = FALSE]
bin_size = 1 / bin_num
bin_size
cov_matrices = array(0, dim = c(dim(A)[1], dim(A)[1], bin_num)) #(51,51,bin_num)
bin_mids = c()
bin_counts = c()
i = 2
bin_min = min(B) + (i - 1) * bin_size  - 1 * bin_size
bin_min = quantile(B,(i - 1) * bin_size)[[1]]
bin_max = quantile(B,(i) * bin_size)[[1]]
bin_mid = quantile(B,(i - 0.5) * bin_size)[[1]]
bin_min
bin_max
bin_mid
bin_mask = (B >= bin_min) & (B < bin_max)
bin_points = B[bin_mask]
bin_counts = c(bin_counts, length(bin_points))
residuals_in_bin = Residual[bin_mask,]
dim(residuals_in_bin)
MASS::cov.rob(residuals_in_bin[1:100,])$cov
data <- residuals_in_bin
n <- ncol(data)
for (i in 1:(n-1)) {
for (j in (i+1):n) {
cov_ij <- cov(data[, i], data[, j])
cor_ij <- cor(data[, i], data[, j])
if (abs(cor_ij) > 0.95) {
cat(colnames(data)[i], "and", colnames(data)[j], ": correlation =", cor_ij, "\n")
}
}
}
for (i in 1:(n-1)) {
for (j in (i+1):n) {
cov_ij <- cov(data[, i], data[, j])
cor_ij <- cor(data[, i], data[, j])
print(cor_ij)
if (abs(cor_ij) > 0.95) {
cat(colnames(data)[i], "and", colnames(data)[j], ": correlation =", cor_ij, "\n")
}
}
}
cor_list = c()
data <- residuals_in_bin
n <- ncol(data)
cor_list = c()
for (i in 1:(n-1)) {
for (j in (i+1):n) {
cov_ij <- cov(data[, i], data[, j])
cor_ij <- cor(data[, i], data[, j])
cor_list = c(cor_list,cor_ij)
if (abs(cor_ij) > 0.95) {
cat(colnames(data)[i], "and", colnames(data)[j], ": correlation =", cor_ij, "\n")
}
}
}
max(cor_list)
ccc = cov(residuals_in_bin)
View(ccc)
data <- residuals_in_bin
n <- ncol(data)
cor_list = c()
cov_list = c()
for (i in 1:(n-1)) {
for (j in (i+1):n) {
cov_ij <- cov(data[, i], data[, j])
cor_ij <- cor(data[, i], data[, j])
cor_list = c(cor_list,cor_ij)
cov_list = c(cov_list,cov_ij)
if (abs(cor_ij) > 0.95) {
cat(colnames(data)[i], "and", colnames(data)[j], ": correlation =", cor_ij, "\n")
}
}
}
max(cov_list)
max(ccc)
det(ccc)
cov_matrix = cov(residuals_in_bin)
det(cov_matrix)
inv_cov <- solve(cov_matrix)
function(data, z_thresh = 3) {
data <- as.data.frame(data)
n <- ncol(data)
cov_matrix <- matrix(NA, nrow = n, ncol = n)
colnames(cov_matrix) <- colnames(data)
rownames(cov_matrix) <- colnames(data)
for (i in 1:(n - 1)) {
for (j in (i + 1):n) {
x <- data[[i]]
y <- data[[j]]
# 计算 Z-score
z_x <- (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)
z_y <- (y - mean(y, na.rm = TRUE)) / sd(y, na.rm = TRUE)
# 标记异常值
x_outlier <- abs(z_x) > z_thresh
y_outlier <- abs(z_y) > z_thresh
# 排除异常值
keep <- !(x_outlier | y_outlier)
# 计算协方差
cov_ij <- cov(x[keep], y[keep], use = "complete.obs")
cov_matrix[i, j] <- cov_ij
cov_matrix[j, i] <- cov_ij  # 对称填充
}
}
# 对角线填入每列的方差（排除异常值）
for (i in 1:n) {
x <- data[[i]]
z_x <- (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)
x_outlier <- abs(z_x) > z_thresh
keep <- !x_outlier
cov_matrix[i, i] <- var(x[keep], na.rm = TRUE)
}
return(cov_matrix)
}
cov_matrix = robust_pairwise_cov_zscore(residuals_in_bin)
robust_pairwise_cov_zscore <- function(data, z_thresh = 3) {
data <- as.data.frame(data)
n <- ncol(data)
cov_matrix <- matrix(NA, nrow = n, ncol = n)
colnames(cov_matrix) <- colnames(data)
rownames(cov_matrix) <- colnames(data)
for (i in 1:(n - 1)) {
for (j in (i + 1):n) {
x <- data[[i]]
y <- data[[j]]
# 计算 Z-score
z_x <- (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)
z_y <- (y - mean(y, na.rm = TRUE)) / sd(y, na.rm = TRUE)
# 标记异常值
x_outlier <- abs(z_x) > z_thresh
y_outlier <- abs(z_y) > z_thresh
# 排除异常值
keep <- !(x_outlier | y_outlier)
# 计算协方差
cov_ij <- cov(x[keep], y[keep], use = "complete.obs")
cov_matrix[i, j] <- cov_ij
cov_matrix[j, i] <- cov_ij  # 对称填充
}
}
# 对角线填入每列的方差（排除异常值）
for (i in 1:n) {
x <- data[[i]]
z_x <- (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)
x_outlier <- abs(z_x) > z_thresh
keep <- !x_outlier
cov_matrix[i, i] <- var(x[keep], na.rm = TRUE)
}
return(cov_matrix)
}
cov_matrix = robust_pairwise_cov_zscore(residuals_in_bin)
View(cov_matrix)
devtools::document()
